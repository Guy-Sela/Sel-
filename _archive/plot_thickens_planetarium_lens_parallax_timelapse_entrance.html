<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Plot Thickens — Lens + Parallax (Timelapse, Entrance Flow)</title>
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        .hud {
            position: fixed;
            left: 16px;
            top: 14px;
            color: rgba(255, 255, 255, 0.78);
            font-size: 13px;
            line-height: 1.35;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 1px 12px rgba(0, 0, 0, 0.85);
            white-space: pre;
        }

        .hint {
            position: fixed;
            left: 16px;
            bottom: 14px;
            color: rgba(255, 255, 255, 0.62);
            font-size: 12px;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 1px 12px rgba(0, 0, 0, 0.85);
        }
    </style>
</head>

<body>
    <div class="hud" id="hud"></div>
    <div class="hint">Entrance at bottom. Drag to look. Space: pause. R: reset. ↑/↓ or +/-: time scale. [ / ]: trail
        length.</div>
    <div id="error-msg"
        style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(50,0,0,0.9); padding:20px; color:white; display:none; z-index:9999; max-width:80%;">
    </div>

    <script>
        window.onerror = function (msg, url, line) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerHTML = "Error: " + msg + "<br><small>" + url + ":" + line + "</small><br><br>If THREE is not defined, check your internet connection or ad blocker.";
        };
    </script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
        import * as THREE from "three";

        // This file is a timelapse variant of `plot_thickens_planetarium_lens_parallax.html`.
        // The trick: run animation on a simulated time axis (simTime) that can be accelerated.
        //
        // Entrance flow variant:
        // Guests enter from a bottom "entrance" and then spread out into clusters/zones.

        // ----------------------------
        // Base scene
        // ----------------------------
        const DOME_RADIUS = 10;
        const CAMERA_EYE_HEIGHT = 1.55;
        const DOME_PHI_MAX = Math.PI * 0.86;

        // Entrance (bottom) in spherical coordinates.
        // Metaphor: a doorway along the horizon line where people stream in, then disperse.
        // Note: camera initially looks roughly toward -Z, which corresponds to theta ≈ 3π/2 in our mapping.
        const ENTRANCE_THETA = Math.PI * 1.5; // forward (-Z)
        // Keep this near the "bottom" but not so low it starts outside the camera frustum.
        // (phi is measured from +Y: phi=π/2 is horizon; >π/2 is "below horizon")
        const ENTRANCE_PHI = 1.95; // ~112° from zenith (bottom-ish but still visible)
        const ENTRANCE_SPREAD_THETA = 0.10; // width of the doorway (left/right)
        const ENTRANCE_SPREAD_PHI = 0.03; // vertical doorway spread
        const ARRIVAL_WINDOW = 30.0; // seconds of sim time for staged arrivals
        const HOLD_AFTER_ARRIVAL = 1.5; // brief hesitation after entering (seconds)
        const SIM_DURATION = 3 * 60 * 60; // 3 hours in sim time (seconds)
        const DEPARTURE_WINDOW = 45 * 60; // last 45 min: people start leaving

        const STAR_COUNT = 6500;
        // Constellations vs. guests:
        // Most points are a static clustered sky (constellations), a smaller subset are "guests" that move.
        const GUEST_FRACTION = 0.10;
        const STAR_LAYERS = [
            { fraction: 0.46, size: 0.007 },
            { fraction: 0.26, size: 0.010 },
            { fraction: 0.14, size: 0.014 },
            { fraction: 0.08, size: 0.019 },
            { fraction: 0.045, size: 0.027 },
            { fraction: 0.015, size: 0.044 }
        ];

        // Parallax shells (Option D): more separation => more noticeable parallax from tiny camera sway.
        // (Near stars should “slide” a bit more than far stars when the camera translates.)
        const STAR_SHELLS = [
            { fraction: 0.22, radiusMul: 0.86 },  // near
            { fraction: 0.34, radiusMul: 0.93 },  // mid
            { fraction: 0.44, radiusMul: 0.995 }  // far
        ];

        // Tiny translation scale for parallax reveal (metaphor: subtle body shift while standing).
        const PARALLAX_STRENGTH = 1.0;

        // Venue "constellations": 5 sub-venues scattered around the dome where people circulate.
        const CLUSTER_COUNT = 5;
        const CLUSTER_FRACTION = 0.70; // background stars still somewhat clustered, but guests define the main "constellations"
        // Tighter clusters (more “constellation” feel)
        const CLUSTER_SIGMA_THETA = 0.06;
        const CLUSTER_SIGMA_PHI = 0.045;
        // Movement speed (slower = more human wandering, less “shooting” across the dome)
        const HUMAN_SPEED = [0.0000007, 0.0000025]; // slower walk pace
        const GROUPED_FRACTION = 0.85;
        const GROUP_SIZE_WEIGHTS = [
            { n: 1, w: 0.15 },
            { n: 2, w: 0.45 },
            { n: 3, w: 0.28 },
            { n: 4, w: 0.12 }
        ];

        // Lens (Option C)
        const LENS_DISTORT = 0.11;
        const LENS_VIGNETTE = 0.35;
        const LENS_SHARPNESS = 0.88;

        // "Long exposure" trails:
        // User request: trails should NOT fade -> 1.0 (infinite persistence).
        // We avoid blowout by using a max-composite in the trail pass, and we avoid "dotted"
        // trails by sub-stepping the sim and accumulating multiple micro-frames per RAF tick.
        // For a 3-hour sim, infinite persistence quickly overwhelms the sky.
        // This keeps long trails but still preserves the constellation field.
        let TRAIL_DECAY = 0.997;

        // Timelapse trail quality: smaller step => more continuous trails (more GPU work).
        const MAX_SIM_STEP = 0.04; // smaller step => smoother, less “dotted” trails
        const MAX_SUBSTEPS = 32; // safety cap

        // Timelapse controls
        let isPaused = false;
        // IMPORTANT: Trails come from accumulation, not from making motion unrealistically fast.
        // This keeps motion human by default; you can still speed it up with ↑/↓.
        let timeScale = 1.0; // default timelapse factor (adjust with ↑/↓)
        const MOTION_SCALE = 0.02; // extra global slow-down on top of timeScale
        const MIN_SUBSTEPS = 4; // force multiple micro-steps to avoid dotted trails
        let simTime = 0;

        const hudEl = document.getElementById("hud");

        // ----------------------------
        // Global sub-venues ("constellations") shared across ALL star groups
        // ----------------------------
        // Metaphor: 5 “rooms” around the venue where people gather and circulate.
        // IMPORTANT: must be shared across shells/layers; otherwise you never get 5 consistent constellations.
        const VENUE_THETA = new Float32Array(CLUSTER_COUNT);
        const VENUE_PHI = new Float32Array(CLUSTER_COUNT);
        const VENUE_SHAPE = new Int8Array(CLUSTER_COUNT); // 0=blob, 1=line, 2=arc (affects static star clustering)
        const VENUE_ORIENT = new Float32Array(CLUSTER_COUNT);
        const VENUE_ASPECT = new Float32Array(CLUSTER_COUNT);
        const VENUE_DRIFT_A = new Float32Array(CLUSTER_COUNT);
        const VENUE_DRIFT_B = new Float32Array(CLUSTER_COUNT);
        initVenues();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.05, 200);
        camera.position.set(0, CAMERA_EYE_HEIGHT, 0);
        camera.lookAt(0, CAMERA_EYE_HEIGHT + 0.4, -1);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);
        // Ensure keyboard input works reliably: make BOTH body and canvas focusable,
        // and (re)focus the canvas on pointer interactions.
        document.body.tabIndex = 0;
        renderer.domElement.tabIndex = 0;
        renderer.domElement.style.outline = "none";
        // Some browsers won't allow focus() until after a user gesture; we also focus on pointerdown.
        try { renderer.domElement.focus(); } catch (_) { }

        // Dome backdrop
        const skyTex = createSkyTexture(1024, 512);
        skyTex.wrapS = THREE.RepeatWrapping;
        skyTex.wrapT = THREE.ClampToEdgeWrapping;
        skyTex.anisotropy = 4;

        const domeGeo = new THREE.SphereGeometry(DOME_RADIUS, 64, 48, 0, Math.PI * 2, 0, DOME_PHI_MAX);
        const domeMat = new THREE.MeshBasicMaterial({ side: THREE.BackSide, map: skyTex, transparent: false });
        const dome = new THREE.Mesh(domeGeo, domeMat);
        dome.position.y = CAMERA_EYE_HEIGHT;
        dome.renderOrder = -10;
        domeMat.depthWrite = false;
        scene.add(dome);

        // (Horizon glow removed for clean black background in timelapse mode)

        // Stars
        const STAR_SPRITE_TEX = makeStarSpriteTexture();
        const starGroups = [];
        buildStarsAcrossShells();
        starGroups.forEach((g) => {
            scene.add(g.points);
            scene.add(g.lines);
        });

        // ----------------------------
        // Post: lens distortion + vignette
        // ----------------------------
        const post = {
            // 1) sceneRT: render the 3D scene (stars/dome) here
            sceneRT: new THREE.WebGLRenderTarget(1, 1, {
                format: THREE.RGBAFormat,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                depthBuffer: true,
                stencilBuffer: false
            }),
            // 2) warpRT: lens warp output (so we can accumulate trails in screen space)
            warpRT: new THREE.WebGLRenderTarget(1, 1, {
                format: THREE.RGBAFormat,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                depthBuffer: false,
                stencilBuffer: false
            }),
            // 3) accumulation ping-pong targets for long-exposure trails
            accumA: new THREE.WebGLRenderTarget(1, 1, {
                format: THREE.RGBAFormat,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                depthBuffer: false,
                stencilBuffer: false
            }),
            accumB: new THREE.WebGLRenderTarget(1, 1, {
                format: THREE.RGBAFormat,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                depthBuffer: false,
                stencilBuffer: false
            }),
            scene: new THREE.Scene(),
            cam: new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            mat: null,
            trailMat: null,
            blitMat: null,
            accumFlip: false
        };

        post.mat = new THREE.ShaderMaterial({
            depthTest: false,
            depthWrite: false,
            uniforms: {
                tScene: { value: post.sceneRT.texture },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                k: { value: LENS_DISTORT },
                vignette: { value: LENS_VIGNETTE },
                sharpness: { value: LENS_SHARPNESS }
            },
            vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 0.0, 1.0);
          }
        `,
            fragmentShader: `
          precision highp float;
          uniform sampler2D tScene;
          uniform vec2 resolution;
          uniform float k;
          uniform float vignette;
          uniform float sharpness;
          varying vec2 vUv;

          float smoothstep01(float a, float b, float x) {
            float t = clamp((x - a) / (b - a), 0.0, 1.0);
            return t * t * (3.0 - 2.0 * t);
          }

          void main() {
            vec2 uv = vUv;
            vec2 c = vec2(0.5);
            vec2 d = uv - c;
            float r2 = dot(d, d);

            vec2 warped = c + d * (1.0 + k * r2);

            // Fade out instead of clamping to avoid “edge streaks”.
            vec2 q = abs(warped - c) * 2.0;
            float edge = max(q.x, q.y);
            float edgeMask = smoothstep01(1.04, 0.98, edge);

            vec3 col = texture2D(tScene, warped).rgb * edgeMask;

            float r = sqrt(r2) / 0.7071;
            float vig = smoothstep01(1.0, sharpness, r);
            col *= mix(1.0, vig, vignette);

            gl_FragColor = vec4(col, 1.0);
          }
        `
        });
        const warpQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), post.mat);
        post.scene.add(warpQuad);

        // Trails composite (screen-space accumulation):
        // accumNext = max(prev * decay, dilated(curr))
        post.trailMat = new THREE.ShaderMaterial({
            depthTest: false,
            depthWrite: false,
            uniforms: {
                tPrev: { value: post.accumA.texture },
                tCurr: { value: post.warpRT.texture },
                decay: { value: TRAIL_DECAY },
                texel: { value: new THREE.Vector2(1 / Math.max(1, window.innerWidth), 1 / Math.max(1, window.innerHeight)) }
            },
            vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 0.0, 1.0);
          }
        `,
            fragmentShader: `
          precision highp float;
          uniform sampler2D tPrev;
          uniform sampler2D tCurr;
          uniform float decay;
          uniform vec2 texel;
          varying vec2 vUv;
          void main() {
            vec3 prev = texture2D(tPrev, vUv).rgb;
            // Smooth stamp (small blur) to avoid “dotty” trails when motion is sampled per frame.
            // This acts like a light paintbrush rather than a hard pixel stamp.
            vec3 c0 = texture2D(tCurr, vUv).rgb;
            vec3 c1 = texture2D(tCurr, vUv + vec2(texel.x, 0.0)).rgb;
            vec3 c2 = texture2D(tCurr, vUv + vec2(-texel.x, 0.0)).rgb;
            vec3 c3 = texture2D(tCurr, vUv + vec2(0.0, texel.y)).rgb;
            vec3 c4 = texture2D(tCurr, vUv + vec2(0.0, -texel.y)).rgb;
            vec3 c5 = texture2D(tCurr, vUv + vec2(texel.x, texel.y)).rgb;
            vec3 c6 = texture2D(tCurr, vUv + vec2(-texel.x, texel.y)).rgb;
            vec3 c7 = texture2D(tCurr, vUv + vec2(texel.x, -texel.y)).rgb;
            vec3 c8 = texture2D(tCurr, vUv + vec2(-texel.x, -texel.y)).rgb;

            // 3x3 Gaussian-ish blur
            vec3 blur = (4.0*c0 + 2.0*(c1+c2+c3+c4) + (c5+c6+c7+c8)) / 16.0;
            // Slightly wider support (cheap “5x5-ish” using radius 2 cross + diagonals)
            vec2 t2 = texel * 2.0;
            vec3 d1 = texture2D(tCurr, vUv + vec2(t2.x, 0.0)).rgb;
            vec3 d2 = texture2D(tCurr, vUv + vec2(-t2.x, 0.0)).rgb;
            vec3 d3 = texture2D(tCurr, vUv + vec2(0.0, t2.y)).rgb;
            vec3 d4 = texture2D(tCurr, vUv + vec2(0.0, -t2.y)).rgb;
            vec3 d5 = texture2D(tCurr, vUv + vec2(t2.x, t2.y)).rgb;
            vec3 d6 = texture2D(tCurr, vUv + vec2(-t2.x, t2.y)).rgb;
            vec3 d7 = texture2D(tCurr, vUv + vec2(t2.x, -t2.y)).rgb;
            vec3 d8 = texture2D(tCurr, vUv + vec2(-t2.x, -t2.y)).rgb;
            vec3 blur2 = (4.0*c0 + (d1+d2+d3+d4) + 0.7*(d5+d6+d7+d8)) / (4.0 + 4.0 + 0.7*4.0);

            // Keep peaks from disappearing (use max of original and blended blur)
            vec3 curr = max(c0, mix(blur, blur2, 0.55));

            // Max-composite keeps trails from fading when decay=1.0, without accumulating to white.
            vec3 col = max(prev * decay, curr);
            gl_FragColor = vec4(col, 1.0);
          }
        `
        });

        // Blit pass (render a texture to screen)
        post.blitMat = new THREE.ShaderMaterial({
            depthTest: false,
            depthWrite: false,
            uniforms: { t: { value: post.accumA.texture } },
            vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 0.0, 1.0);
          }
        `,
            fragmentShader: `
          precision highp float;
          uniform sampler2D t;
          varying vec2 vUv;
          void main() {
            gl_FragColor = vec4(texture2D(t, vUv).rgb, 1.0);
          }
        `
        });

        // ----------------------------
        // Interaction: drag to look around (yaw/pitch)
        // ----------------------------
        // Start looking closer to the horizon so the entrance (bottom) is visible immediately.
        const look = { yaw: 0, pitch: 0.55, targetYaw: 0, targetPitch: 0.55 };
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        renderer.domElement.addEventListener("pointerdown", (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            // Re-acquire focus so arrow keys work while interacting.
            try { renderer.domElement.focus(); } catch (_) { }
            renderer.domElement.setPointerCapture(e.pointerId);
            // Trails are accumulated in screen space; changing viewpoint will smear history.
            // Clear at drag start so the trail field matches the new view.
            clearAccum();
        });
        renderer.domElement.addEventListener("pointerup", (e) => {
            isDragging = false;
            try {
                renderer.domElement.releasePointerCapture(e.pointerId);
            } catch (_) { }
            // Clear again on release to avoid a “mixed” frame between two viewpoints.
            clearAccum();
        });
        renderer.domElement.addEventListener("pointermove", (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;
            look.targetYaw += dx * 0.004;
            look.targetPitch += dy * 0.004;
            look.targetPitch = Math.max(-0.05, Math.min(1.25, look.targetPitch));
        });

        // Keyboard controls (robust across layouts)
        const handleKey = (e) => {
            const k = e.key;
            const code = e.code;
            const keyCode = e.keyCode || e.which || 0;
            const kl = (k && k.toLowerCase) ? k.toLowerCase() : k;
            if (k === " " || k === "Spacebar") {
                e.preventDefault();
                isPaused = !isPaused;
            } else if (kl === "r") {
                simTime = 0;
                clearAccum();
            } else if (
                k === "ArrowUp" || k === "Up" || code === "ArrowUp" || keyCode === 38 ||
                code === "NumpadAdd" || k === "+" || k === "="
            ) {
                e.preventDefault();
                // Don't round: rounding makes low values (like 1) never change.
                timeScale = Math.min(600, timeScale * 1.25);
            } else if (
                k === "ArrowDown" || k === "Down" || code === "ArrowDown" || keyCode === 40 ||
                code === "NumpadSubtract" || k === "-" || k === "_"
            ) {
                e.preventDefault();
                timeScale = Math.max(0.1, timeScale / 1.25);
            } else if (k === "[") {
                TRAIL_DECAY = Math.max(0.90, TRAIL_DECAY - 0.005);
                post.trailMat.uniforms.decay.value = TRAIL_DECAY;
            } else if (k === "]") {
                TRAIL_DECAY = Math.min(1.0, TRAIL_DECAY + 0.005);
                post.trailMat.uniforms.decay.value = TRAIL_DECAY;
            }
        };
        // Use capture phase so we still receive keys even if something stops propagation.
        window.addEventListener("keydown", handleKey, { passive: false, capture: true });
        document.addEventListener("keydown", handleKey, { passive: false, capture: true });

        // ----------------------------
        // Animate (simulated time)
        // ----------------------------
        const clock = new THREE.Clock();
        let realTime = 0; // real seconds (not affected by timelapse)
        function animate() {
            requestAnimationFrame(animate);
            const dtReal = Math.min(clock.getDelta(), 0.05);
            realTime += dtReal;
            const dtSimTotal = isPaused ? 0 : dtReal * timeScale * MOTION_SCALE;

            // Ease look on real time (still feels “human” while timelapse runs)
            look.yaw += (look.targetYaw - look.yaw) * (1 - Math.pow(0.0007, dtReal));
            look.pitch += (look.targetPitch - look.pitch) * (1 - Math.pow(0.0007, dtReal));

            // Substep the simulation + accumulation so trails become continuous at high timeScale.
            const subSteps = isPaused
                ? 1
                : Math.min(
                    MAX_SUBSTEPS,
                    Math.max(MIN_SUBSTEPS, Math.ceil(dtSimTotal / MAX_SIM_STEP))
                );
            const dtSim = subSteps > 0 ? dtSimTotal / subSteps : 0;

            for (let s = 0; s < subSteps; s++) {
                if (!isPaused) {
                    simTime += dtSim;
                    for (const g of starGroups) updateStars(g, dtSim, simTime);
                }

                // Tiny sway uses REAL time (stable parallax, independent of timelapse speed).
                const swayX = (Math.sin(realTime * 0.35) * 0.040 + Math.sin(realTime * 0.11) * 0.018) * PARALLAX_STRENGTH;
                const swayZ = (Math.cos(realTime * 0.29) * 0.030) * PARALLAX_STRENGTH;
                const bobY = Math.sin(realTime * 0.23) * 0.010 * PARALLAX_STRENGTH;
                camera.position.set(swayX, CAMERA_EYE_HEIGHT + bobY, swayZ);

                const dir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(look.pitch, look.yaw, 0, "YXZ"));
                camera.lookAt(camera.position.clone().add(dir));

                // 1) Render 3D scene
                renderer.setRenderTarget(post.sceneRT);
                renderer.render(scene, camera);

                // 2) Lens warp to warpRT
                renderer.setRenderTarget(post.warpRT);
                renderer.render(post.scene, post.cam);

                // 3) Accumulate trails
                const prev = post.accumFlip ? post.accumB : post.accumA;
                const next = post.accumFlip ? post.accumA : post.accumB;

                // Skip accumulation while paused (freeze) OR while dragging (avoid smear).
                if (!isPaused && !isDragging) {
                    const prevMat = warpQuad.material;
                    warpQuad.material = post.trailMat;
                    post.trailMat.uniforms.tPrev.value = prev.texture;
                    post.trailMat.uniforms.tCurr.value = post.warpRT.texture;
                    renderer.setRenderTarget(next);
                    renderer.render(post.scene, post.cam);
                    warpQuad.material = prevMat;
                    post.accumFlip = !post.accumFlip;
                }
            }

            // 4) Blit accumulated buffer to screen
            // While dragging, show the live warped frame instead of the accumulated trail buffer.
            const showTex = isDragging ? post.warpRT.texture : (post.accumFlip ? post.accumB.texture : post.accumA.texture);
            post.blitMat.uniforms.t.value = showTex;
            const prevMat2 = warpQuad.material;
            warpQuad.material = post.blitMat;
            renderer.setRenderTarget(null);
            renderer.render(post.scene, post.cam);
            warpQuad.material = prevMat2;

            const simSec = simTime;
            hudEl.textContent =
                "The Plot Thickens — lens+parallax timelapse\n" +
                `timeScale: ${timeScale.toFixed(2)}×   ` +
                (isPaused ? "(paused)   " : "") +
                `simTime: ${formatTime(simTime)}  (${simSec.toFixed(2)}s / ${(SIM_DURATION / 3600).toFixed(0)}h)\n` +
                `[Drag] look (trails pause)   [↑/↓] or +/- speed   [Space] pause   [R] reset   [/] decay: ${TRAIL_DECAY.toFixed(3)}   substeps: ${subSteps}`;
        }
        animate();

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            post.mat.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            resizeRenderTarget();
        });
        resizeRenderTarget();

        function resizeRenderTarget() {
            const pr = renderer.getPixelRatio();
            const w = Math.max(1, Math.floor(window.innerWidth * pr));
            const h = Math.max(1, Math.floor(window.innerHeight * pr));
            post.sceneRT.setSize(w, h);
            post.warpRT.setSize(w, h);
            post.accumA.setSize(w, h);
            post.accumB.setSize(w, h);
            if (post.trailMat && post.trailMat.uniforms && post.trailMat.uniforms.texel) {
                post.trailMat.uniforms.texel.value.set(1 / w, 1 / h);
            }
            clearAccum();
        }

        function clearAccum() {
            // Clear both accumulation buffers to black.
            const prevClear = renderer.getClearColor(new THREE.Color()).getHex();
            const prevAlpha = renderer.getClearAlpha();
            renderer.setClearColor(0x000000, 1);
            renderer.setRenderTarget(post.accumA);
            renderer.clear(true, true, true);
            renderer.setRenderTarget(post.accumB);
            renderer.clear(true, true, true);
            renderer.setRenderTarget(null);
            renderer.setClearColor(prevClear, prevAlpha);
        }

        function formatTime(seconds) {
            const s = Math.max(0, seconds);
            const hh = Math.floor(s / 3600);
            const mm = Math.floor((s % 3600) / 60);
            const ss = Math.floor(s % 60);
            const pad = (n) => String(n).padStart(2, "0");
            return `${pad(hh)}:${pad(mm)}:${pad(ss)}`;
        }

        // ----------------------------
        // Stars: build across shells
        // ----------------------------
        function buildStarsAcrossShells() {
            let shellRemaining = STAR_COUNT;
            for (let si = 0; si < STAR_SHELLS.length; si++) {
                const shellCount =
                    si === STAR_SHELLS.length - 1 ? shellRemaining : Math.floor(STAR_COUNT * STAR_SHELLS[si].fraction);
                shellRemaining -= shellCount;

                let rem = shellCount;
                for (let li = 0; li < STAR_LAYERS.length; li++) {
                    const count = li === STAR_LAYERS.length - 1 ? rem : Math.floor(shellCount * STAR_LAYERS[li].fraction);
                    rem -= count;
                    const guestCount = Math.floor(count * GUEST_FRACTION);
                    const staticCount = Math.max(0, count - guestCount);
                    if (staticCount > 0) starGroups.push(createStars(staticCount, STAR_LAYERS[li].size, DOME_RADIUS * STAR_SHELLS[si].radiusMul, "static"));
                    if (guestCount > 0) starGroups.push(createStars(guestCount, STAR_LAYERS[li].size, DOME_RADIUS * STAR_SHELLS[si].radiusMul, "guests"));
                }
            }
        }

        function createStars(count, size, radius, mode) {
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const baseColors = new Float32Array(count * 3);

            const theta = new Float32Array(count);
            const phi = new Float32Array(count);

            const groupId = new Int32Array(count);
            const offTheta = new Float32Array(count);
            const offPhi = new Float32Array(count);

            const jitterPhaseA = new Float32Array(count);
            const jitterPhaseB = new Float32Array(count);
            const jitterSpd = new Float32Array(count);

            const baseB = new Float32Array(count);
            const twinkleSpd = new Float32Array(count);
            const twinklePhase = new Float32Array(count);

            // Venue centers (shared globally): 5 consistent "constellations" around the venue.
            const clustersTheta = VENUE_THETA;
            const clustersPhi = VENUE_PHI;
            const clustersDriftA = VENUE_DRIFT_A;
            const clustersDriftB = VENUE_DRIFT_B;
            // Constellation “shape” per venue (affects static star clustering only)
            const clusterShape = VENUE_SHAPE; // 0=blob, 1=line, 2=arc
            const clusterOrient = VENUE_ORIENT;
            const clusterAspect = VENUE_ASPECT;

            let i = 0;
            let gCount = 0;
            const gAnchorTheta = [];
            const gAnchorPhi = [];
            const gVelTheta = [];
            const gVelPhi = [];
            const gCluster = [];
            const gAct = [];
            const gActBase = [];
            // Per-group individuality (breaks “everyone moves the same way” feeling)
            const gSpeedBase = [];
            const gWanderA = [];
            const gWanderB = [];
            const gWanderF = [];
            // Venue-wandering state (move between clusters / POIs, rarely in circles)
            const gState = []; // 0=TRANSIT, 1=LINGER
            const gTimer = [];
            const gTargetTheta = [];
            const gTargetPhi = [];
            const gTargetCluster = [];
            // A fraction of groups are roamers (they traverse across the whole venue more often)
            const gRoamer = [];
            // Entrance flow (guests only): staged entry + staged exit.
            const gStartTime = [];
            const gEndTime = [];
            const gEntered = [];
            const gExited = [];
            const gHasSettled = []; // reached a venue at least once (so entry is a short “walk-in”, not a long ray)
            // Smooth individuality: per-group meander + curvature tendencies (smooth, no jitter)
            const gMeanderAmp = [];
            const gMeanderPhase = [];
            const gMeanderFreq = [];
            const gCurveBias = [];
            const gCurveAmpMul = [];
            // Mid-path replanning (guests): occasionally change destination while in transit.
            const gNextReplanTime = [];
            const gReplanMin = [];
            const gReplanMax = [];
            // Sub-venue circulation (guests): orbit-like motion while lingering.
            const gOrbitPhase = [];
            const gOrbitSpeed = [];
            const gOrbitRTheta = [];
            const gOrbitRPhi = [];
            // Smooth path segment (straight or curved) between targets (guarantees non-jittery trails)
            const gSegDur = []; // seconds
            const gTheta0U = []; // unwrapped theta start
            const gTheta3U = []; // unwrapped theta end
            const gPhi0 = [];
            const gPhi3 = [];
            const gC1ThetaU = [];
            const gC2ThetaU = [];
            const gC1Phi = [];
            const gC2Phi = [];

            while (i < count) {
                const makeGroup = Math.random() < GROUPED_FRACTION;
                const groupSize = makeGroup ? pickGroupSize() : 1;
                const actualSize = Math.min(groupSize, count - i);

                let aTheta, aPhi;
                if (mode === "guests") {
                    // Guests: start near the entrance, then spread into the venue.
                    gCluster[gCount] = -1;
                    gRoamer[gCount] = Math.random() < 0.22 ? 1 : 0;

                    // Stagger arrivals (first part of the 3h event).
                    gStartTime[gCount] = Math.pow(Math.random(), 1.6) * ARRIVAL_WINDOW;
                    // Schedule departure sometime in the last window.
                    gEndTime[gCount] = (SIM_DURATION - DEPARTURE_WINDOW) + Math.pow(Math.random(), 1.25) * DEPARTURE_WINDOW;
                    gEntered[gCount] = 0;
                    gExited[gCount] = 0;
                    gHasSettled[gCount] = 0;
                    gHasSettled[gCount] = 1;

                    // Initial anchor near entrance
                    aTheta = wrapAngle(ENTRANCE_THETA + randn() * ENTRANCE_SPREAD_THETA);
                    aPhi = clampPhi(ENTRANCE_PHI + randn() * ENTRANCE_SPREAD_PHI);
                } else {
                    // Static constellations: clustered distribution across the dome.
                    const inCluster = Math.random() < CLUSTER_FRACTION;
                    let cid = -1;
                    if (inCluster) cid = Math.floor(Math.random() * CLUSTER_COUNT);
                    gCluster[gCount] = cid;
                    gRoamer[gCount] = 0;

                    if (cid >= 0) {
                        // Sample around cluster center with optional constellation-like shape.
                        const sh = clusterShape[cid];
                        const ang = clusterOrient[cid];
                        const cs = Math.cos(ang), sn = Math.sin(ang);
                        // Local (x,y) in "theta/phi" plane
                        let x = randn() * CLUSTER_SIGMA_THETA;
                        let y = randn() * CLUSTER_SIGMA_PHI;
                        if (sh === 1) {
                            // line: compress one axis, stretch the other
                            const asp = clusterAspect[cid];
                            x *= asp;
                            y *= 0.35;
                        } else if (sh === 2) {
                            // arc: points tend to lie on a curved band
                            const asp = clusterAspect[cid];
                            const u = randn() * 0.9;
                            x = u * CLUSTER_SIGMA_THETA * asp;
                            y = (0.35 * u * u + randn() * 0.35) * CLUSTER_SIGMA_PHI;
                        }
                        // Rotate
                        const rx = x * cs - y * sn;
                        const ry = x * sn + y * cs;
                        aTheta = wrapAngle(clustersTheta[cid] + rx);
                        aPhi = clampPhi(clustersPhi[cid] + ry);
                    } else {
                        aTheta = Math.random() * Math.PI * 2;
                        const cosPhiMax = Math.cos(DOME_PHI_MAX);
                        const cosPhi = cosPhiMax + (1 - cosPhiMax) * Math.random();
                        aPhi = Math.acos(cosPhi);
                    }
                }

                gAnchorTheta[gCount] = aTheta;
                gAnchorPhi[gCount] = aPhi;

                // Activity level controls stop-and-go behavior
                gAct[gCount] = Math.random();
                // Wider distribution: many linger, some roam more.
                gActBase[gCount] = 0.03 + Math.pow(Math.random(), 1.6) * 0.55;

                // Each group has its own walking speed + drift signature (low-frequency bias)
                if (mode === "guests") {
                    // Wider spread: some move faster, some linger/creep.
                    gSpeedBase[gCount] = randRange(HUMAN_SPEED[0], HUMAN_SPEED[1]) * (0.35 + Math.pow(Math.random(), 1.15) * 1.45);
                } else {
                    gSpeedBase[gCount] = 0.0;
                }
                gWanderA[gCount] = Math.random() * Math.PI * 2;
                gWanderB[gCount] = Math.random() * Math.PI * 2;
                gWanderF[gCount] = 0.04 + Math.random() * 0.11; // each group “changes mind” at its own cadence
                gMeanderAmp[gCount] = 0.004 + Math.pow(Math.random(), 1.6) * 0.014;
                gMeanderPhase[gCount] = Math.random() * Math.PI * 2;
                gMeanderFreq[gCount] = 0.55 + Math.random() * 1.9; // different "curvitudes" along the path
                gCurveBias[gCount] = Math.pow(Math.random(), 0.9);  // preference for curved segments
                gCurveAmpMul[gCount] = 0.6 + Math.random() * 1.7;  // how "bendy" the curves get
                // Orbit params: most people do small loops while chatting in a sub-venue.
                gOrbitPhase[gCount] = Math.random() * Math.PI * 2;
                gOrbitSpeed[gCount] = (0.20 + Math.random() * 0.55) * (Math.random() < 0.25 ? 0.45 : 1.0); // some are slower loopers
                gOrbitRTheta[gCount] = 0.010 + Math.pow(Math.random(), 1.6) * 0.055;
                gOrbitRPhi[gCount] = 0.008 + Math.pow(Math.random(), 1.6) * 0.040;
                // Some groups are decisive (rare replans), others are indecisive (many replans).
                if (mode === "guests") {
                    const indecisive = Math.random() < 0.35 ? 1 : 0;
                    // Replans happen over minutes (sim time), not seconds.
                    gReplanMin[gCount] = indecisive ? (2.0 * 60 + Math.random() * 4.0 * 60) : (6.0 * 60 + Math.random() * 10.0 * 60);
                    gReplanMax[gCount] = indecisive ? (5.0 * 60 + Math.random() * 7.0 * 60) : (12.0 * 60 + Math.random() * 18.0 * 60);
                    gNextReplanTime[gCount] = gStartTime[gCount] + randRange(gReplanMin[gCount], gReplanMax[gCount]);
                } else {
                    gReplanMin[gCount] = 999999;
                    gReplanMax[gCount] = 999999;
                    gNextReplanTime[gCount] = 999999;
                }

                if (mode === "guests") {
                    // Start waiting at the entrance until the group's start time.
                    gState[gCount] = 1;
                    gTimer[gCount] = gStartTime[gCount] + HOLD_AFTER_ARRIVAL;
                } else {
                    // Static constellations never move.
                    gState[gCount] = 1;
                    gTimer[gCount] = 999999;
                }
                // Pick an initial destination (guests only)
                let tc = Math.floor(Math.random() * CLUSTER_COUNT);
                gTargetCluster[gCount] = tc;
                gTargetTheta[gCount] = wrapAngle(clustersTheta[tc] + randn() * (CLUSTER_SIGMA_THETA * 0.9));
                gTargetPhi[gCount] = clampPhi(clustersPhi[tc] + randn() * (CLUSTER_SIGMA_PHI * 0.9));

                // Initialize a segment (if we start in transit, it'll be used immediately)
                gSegDur[gCount] = 8.0;
                gTheta0U[gCount] = aTheta;
                gTheta3U[gCount] = aTheta + angleDelta(aTheta, gTargetTheta[gCount]);
                gPhi0[gCount] = aPhi;
                gPhi3[gCount] = gTargetPhi[gCount];
                gC1ThetaU[gCount] = gTheta0U[gCount] + (gTheta3U[gCount] - gTheta0U[gCount]) * (1 / 3);
                gC2ThetaU[gCount] = gTheta0U[gCount] + (gTheta3U[gCount] - gTheta0U[gCount]) * (2 / 3);
                gC1Phi[gCount] = gPhi0[gCount] + (gPhi3[gCount] - gPhi0[gCount]) * (1 / 3);
                gC2Phi[gCount] = gPhi0[gCount] + (gPhi3[gCount] - gPhi0[gCount]) * (2 / 3);

                // Start with a tiny velocity (random direction)
                const sp0 = gSpeedBase[gCount];
                const heading = Math.random() * Math.PI * 2;
                gVelTheta[gCount] = Math.cos(heading) * sp0 * (0.7 + Math.random() * 0.6);
                gVelPhi[gCount] = Math.sin(heading) * sp0 * (0.5 + Math.random() * 0.7);

                for (let k = 0; k < actualSize; k++) {
                    const idx = i + k;
                    groupId[idx] = gCount;

                    // Members sit around the anchor (small fixed offsets)
                    offTheta[idx] = randn() * (0.025 + Math.random() * 0.04);
                    offPhi[idx] = randn() * (0.018 + Math.random() * 0.03);

                    theta[idx] = wrapAngle(aTheta + offTheta[idx]);
                    phi[idx] = clampPhi(aPhi + offPhi[idx]);

                    jitterSpd[idx] = 0.15 + Math.random() * 0.5;
                    jitterPhaseA[idx] = Math.random() * Math.PI * 2;
                    jitterPhaseB[idx] = Math.random() * Math.PI * 2;

                    const b = Math.pow(Math.random(), 2.2);
                    baseB[idx] = 0.18 + b * 0.9;
                    twinkleSpd[idx] = 0.08 + Math.random() * 0.55;
                    twinklePhase[idx] = Math.random() * Math.PI * 2;

                    const temp = Math.random();
                    let r = 1, g = 1, bcol = 1;
                    if (temp < 0.14) {
                        r = 1.0; g = 0.94; bcol = 0.86;
                    } else if (temp < 0.30) {
                        r = 0.86; g = 0.92; bcol = 1.0;
                    } else {
                        r = 0.98; g = 0.99; bcol = 1.0;
                    }

                    const p = sphericalToCartesian(theta[idx], phi[idx], radius);
                    positions[idx * 3 + 0] = p.x;
                    positions[idx * 3 + 1] = p.y + CAMERA_EYE_HEIGHT;
                    positions[idx * 3 + 2] = p.z;

                    baseColors[idx * 3 + 0] = r;
                    baseColors[idx * 3 + 1] = g;
                    baseColors[idx * 3 + 2] = bcol;

                    const bright = baseB[idx];
                    colors[idx * 3 + 0] = r * bright;
                    colors[idx * 3 + 1] = g * bright;
                    colors[idx * 3 + 2] = bcol * bright;
                }

                i += actualSize;
                gCount++;
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({
                size: size * 1.5,
                map: STAR_SPRITE_TEX,
                transparent: true,
                alphaTest: 0.05,
                // Lower head intensity so trails read as continuous strokes (avoid “beads on a string”).
                opacity: 0.4,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true
            });

            const points = new THREE.Points(geom, mat);
            points.renderOrder = 10;

            // Line segments (prev -> curr) so timelapse trails are continuous, not point-stamped.
            const linePositions = new Float32Array(count * 6);
            // init to degenerate segments at the current position
            for (let k = 0; k < count; k++) {
                const x = positions[k * 3 + 0];
                const y = positions[k * 3 + 1];
                const z = positions[k * 3 + 2];
                linePositions[k * 6 + 0] = x;
                linePositions[k * 6 + 1] = y;
                linePositions[k * 6 + 2] = z;
                linePositions[k * 6 + 3] = x;
                linePositions[k * 6 + 4] = y;
                linePositions[k * 6 + 5] = z;
            }
            const lineGeom = new THREE.BufferGeometry();
            lineGeom.setAttribute("position", new THREE.BufferAttribute(linePositions, 3));
            const lineMat = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.65,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false
            });
            const lines = new THREE.LineSegments(lineGeom, lineMat);
            lines.renderOrder = 9;

            // Keep previous positions to draw segments each update.
            const prevPos = new Float32Array(count * 3);
            prevPos.set(positions);

            // Static constellations don't need line drawing; guests do (for continuous trails).
            if (mode !== "guests") lines.visible = false;

            return {
                points,
                lines,
                mode,
                prevPos,
                theta,
                phi,
                groupId,
                offTheta,
                offPhi,
                gAnchorTheta: Float32Array.from(gAnchorTheta),
                gAnchorPhi: Float32Array.from(gAnchorPhi),
                gVelTheta: Float32Array.from(gVelTheta),
                gVelPhi: Float32Array.from(gVelPhi),
                gCluster: Int16Array.from(gCluster),
                gAct: Float32Array.from(gAct),
                gActBase: Float32Array.from(gActBase),
                gSpeedBase: Float32Array.from(gSpeedBase),
                gWanderA: Float32Array.from(gWanderA),
                gWanderB: Float32Array.from(gWanderB),
                gWanderF: Float32Array.from(gWanderF),
                gState: Int8Array.from(gState),
                gTimer: Float32Array.from(gTimer),
                gTargetTheta: Float32Array.from(gTargetTheta),
                gTargetPhi: Float32Array.from(gTargetPhi),
                gTargetCluster: Int16Array.from(gTargetCluster),
                gRoamer: Int8Array.from(gRoamer),
                // Entrance flow fields
                gStartTime: Float32Array.from(gStartTime),
                gEndTime: Float32Array.from(gEndTime),
                gEntered: Int8Array.from(gEntered),
                gExited: Int8Array.from(gExited),
                gHasSettled: Int8Array.from(gHasSettled),
                gMeanderAmp: Float32Array.from(gMeanderAmp),
                gMeanderPhase: Float32Array.from(gMeanderPhase),
                gMeanderFreq: Float32Array.from(gMeanderFreq),
                gCurveBias: Float32Array.from(gCurveBias),
                gCurveAmpMul: Float32Array.from(gCurveAmpMul),
                gNextReplanTime: Float32Array.from(gNextReplanTime),
                gReplanMin: Float32Array.from(gReplanMin),
                gReplanMax: Float32Array.from(gReplanMax),
                gOrbitPhase: Float32Array.from(gOrbitPhase),
                gOrbitSpeed: Float32Array.from(gOrbitSpeed),
                gOrbitRTheta: Float32Array.from(gOrbitRTheta),
                gOrbitRPhi: Float32Array.from(gOrbitRPhi),
                gSegDur: Float32Array.from(gSegDur),
                gTheta0U: Float32Array.from(gTheta0U),
                gTheta3U: Float32Array.from(gTheta3U),
                gPhi0: Float32Array.from(gPhi0),
                gPhi3: Float32Array.from(gPhi3),
                gC1ThetaU: Float32Array.from(gC1ThetaU),
                gC2ThetaU: Float32Array.from(gC2ThetaU),
                gC1Phi: Float32Array.from(gC1Phi),
                gC2Phi: Float32Array.from(gC2Phi),
                jitterSpd,
                jitterPhaseA,
                jitterPhaseB,
                clustersTheta,
                clustersPhi,
                clustersDriftA,
                clustersDriftB,
                clusterShape,
                clusterOrient,
                clusterAspect,
                baseColors,
                baseB,
                twinkleSpd,
                twinklePhase,
                radius
            };
        }

        function updateStars(g, dt, t) {
            // Static constellations: do not move (they form the night sky backdrop).
            if (g.mode !== "guests") return;

            const posAttr = g.points.geometry.getAttribute("position");
            const colAttr = g.points.geometry.getAttribute("color");
            const linePosAttr = g.lines.geometry.getAttribute("position");

            // Keep clusters essentially fixed (venue POIs), so motion reads as people moving between zones.
            // (Drifting attractors tend to create circular/orbital motion.)
            // If you want a tiny "room drift" later, reintroduce with a much smaller drift.

            // Update group anchors (the "person" or group center)
            for (let gi = 0; gi < g.gAnchorTheta.length; gi++) {
                const STATE_TRANSIT = 0;
                const STATE_LINGER = 1;
                const STATE_WAIT_ENTRY = 2;
                const STATE_EXITED = 3;

                // Entrance: before a group enters, keep it near the doorway with minimal motion.
                if (t < g.gStartTime[gi]) {
                    g.gState[gi] = STATE_WAIT_ENTRY;
                    g.gAnchorTheta[gi] = wrapAngle(ENTRANCE_THETA + randn() * (ENTRANCE_SPREAD_THETA * 0.9));
                    g.gAnchorPhi[gi] = clampPhi(ENTRANCE_PHI + randn() * (ENTRANCE_SPREAD_PHI * 0.9));
                    continue;
                }
                // Already exited: stop updating (no new drawing).
                if (g.gState[gi] === STATE_EXITED || g.gExited[gi] === 1) {
                    continue;
                }
                if (g.gEntered[gi] === 0) {
                    // First frame after entry: pick a target and start moving into the venue.
                    g.gEntered[gi] = 1;
                    g.gState[gi] = STATE_TRANSIT;
                    // Ensure we're starting from the entrance (slight random offset so arrivals aren't identical)
                    g.gAnchorTheta[gi] = wrapAngle(ENTRANCE_THETA + randn() * ENTRANCE_SPREAD_THETA);
                    g.gAnchorPhi[gi] = clampPhi(ENTRANCE_PHI + randn() * ENTRANCE_SPREAD_PHI);
                    g.gTimer[gi] = 0.0; // force pickNewTarget below via safety init
                }

                const isExiting = (t >= g.gEndTime[gi]);
                // Exit phase: in the last part of the 3h event, groups head back to the entrance and leave.
                if (isExiting) {
                    g.gTargetCluster[gi] = -1;
                    g.gTargetTheta[gi] = ENTRANCE_THETA;
                    g.gTargetPhi[gi] = ENTRANCE_PHI;
                    // Force a segment rebuild, but do NOT allow random target picking.
                    g.gTimer[gi] = 0.0;
                }
                // Organic activity: only used to vary linger/transit durations a bit.
                const kAct = 0.22;
                const nAct = 0.06 * Math.sqrt(Math.max(0.000001, dt));
                g.gAct[gi] = clamp01(g.gAct[gi] + (g.gActBase[gi] - g.gAct[gi]) * kAct * dt + randn() * nAct);

                // Helper: (re)build a smooth segment between current anchor and a new destination.
                const buildSegmentTo = (targetTheta, targetPhi) => {
                    const th0 = g.gAnchorTheta[gi];
                    const ph0 = g.gAnchorPhi[gi];
                    const dTh = angleDelta(th0, targetTheta);
                    const dPh = targetPhi - ph0;
                    const dist = Math.sqrt(dTh * dTh + dPh * dPh);

                    // Duration based on distance and group speed (clamped)
                    const sp = g.gSpeedBase[gi];
                    // Longer segments = slower perceived motion (more like people strolling).
                    // Special-case the very first leg after entering: get to a venue quickly so
                    // "constellations" show up as circulating clusters instead of entrance rays.
                    const isFirstLeg = (g.gHasSettled[gi] === 0) && !isExiting;
                    const mult = isFirstLeg ? 6.5 : 16.0;
                    const minDur = isFirstLeg ? 14.0 : 40.0;
                    const maxDur = isFirstLeg ? 120.0 : 360.0;
                    const dur = Math.max(minDur, Math.min(maxDur, dist / Math.max(1e-6, sp) * mult));
                    g.gSegDur[gi] = dur;
                    g.gTimer[gi] = dur;

                    // Unwrapped theta endpoints for smooth interpolation
                    const th0u = th0;
                    const th3u = th0u + dTh;
                    g.gTheta0U[gi] = th0u;
                    g.gTheta3U[gi] = th3u;
                    g.gPhi0[gi] = ph0;
                    g.gPhi3[gi] = targetPhi;

                    // Base straight controls
                    let c1Th = th0u + (th3u - th0u) * (1 / 3);
                    let c2Th = th0u + (th3u - th0u) * (2 / 3);
                    let c1Ph = ph0 + (targetPhi - ph0) * (1 / 3);
                    let c2Ph = ph0 + (targetPhi - ph0) * (2 / 3);

                    // Curvature: ALWAYS curved turns (no straight segments). Amount varies per group.
                    if (dist > 0.02) {
                        // Perpendicular in (theta,phi) plane
                        const inv = 1.0 / dist;
                        const vx = dTh * inv;
                        const vy = dPh * inv;
                        const px = -vy;
                        const py = vx;
                        const sign = Math.random() < 0.5 ? -1 : 1;
                        const base = (0.06 + 0.10 * g.gCurveBias[gi]) * g.gCurveAmpMul[gi];
                        const amp = sign * Math.min(0.30, Math.max(0.03, dist * base));
                        c1Th += px * amp;
                        c2Th += px * amp;
                        c1Ph += py * amp;
                        c2Ph += py * amp;
                    }

                    g.gC1ThetaU[gi] = c1Th;
                    g.gC2ThetaU[gi] = c2Th;
                    g.gC1Phi[gi] = clampPhi(c1Ph);
                    g.gC2Phi[gi] = clampPhi(c2Ph);
                };

                const pickNewTarget = () => {
                    const curr = g.gCluster[gi];
                    const preferClusters = g.gRoamer[gi] ? 0.62 : 0.92;
                    if (Math.random() < preferClusters) {
                        let tc = Math.floor(Math.random() * g.clustersTheta.length);
                        if (curr >= 0) {
                            let guard = 0;
                            while (tc === curr && guard++ < 10) tc = Math.floor(Math.random() * g.clustersTheta.length);
                        }
                        g.gTargetCluster[gi] = tc;
                        // Roamers land looser around cluster; non-roamers land tighter (constellation centers)
                        const mul = g.gRoamer[gi] ? 2.2 : 1.0;
                        g.gTargetTheta[gi] = wrapAngle(g.clustersTheta[tc] + randn() * (CLUSTER_SIGMA_THETA * 1.05 * mul));
                        g.gTargetPhi[gi] = clampPhi(g.clustersPhi[tc] + randn() * (CLUSTER_SIGMA_PHI * 1.05 * mul));
                    } else {
                        g.gTargetCluster[gi] = -1;
                        g.gTargetTheta[gi] = Math.random() * Math.PI * 2;
                        const cosPhiMax = Math.cos(DOME_PHI_MAX);
                        const cosPhi = cosPhiMax + (1 - cosPhiMax) * Math.random();
                        g.gTargetPhi[gi] = Math.acos(cosPhi);
                    }
                    buildSegmentTo(g.gTargetTheta[gi], g.gTargetPhi[gi]);
                };

                // Mid-path changes: while in transit, occasionally pick a new target (curved segment rebuild).
                // This makes trajectories feel like real crowd intention changes ("oh, let's go there instead").
                if (g.gState[gi] === STATE_TRANSIT && !isExiting && t >= g.gStartTime[gi]) {
                    // Avoid re-planning too close to current destination (prevents stutter).
                    const distToTarget = Math.sqrt(
                        Math.pow(angleDelta(g.gAnchorTheta[gi], g.gTargetTheta[gi]), 2) +
                        Math.pow(g.gTargetPhi[gi] - g.gAnchorPhi[gi], 2)
                    );
                    if (t >= g.gNextReplanTime[gi] && distToTarget > 0.08) {
                        pickNewTarget();
                        g.gState[gi] = STATE_TRANSIT;
                        g.gNextReplanTime[gi] = t + randRange(g.gReplanMin[gi], g.gReplanMax[gi]);
                    }
                }

                // Safety init (also used to kickstart motion right after entry)
                if (!isFinite(g.gSegDur[gi]) || g.gSegDur[gi] <= 0 || g.gTimer[gi] <= 0) {
                    if (isExiting) {
                        // Build directly toward the entrance (no random targets).
                        buildSegmentTo(ENTRANCE_THETA, ENTRANCE_PHI);
                        g.gState[gi] = STATE_TRANSIT;
                    } else {
                        pickNewTarget();
                        g.gState[gi] = STATE_TRANSIT;
                    }
                }

                if (g.gState[gi] === STATE_LINGER) {
                    // While lingering inside a sub-venue, circulate in small, smooth loops (reads like crowd clusters).
                    g.gTimer[gi] -= dt;

                    // If we're not in a cluster (should be rare), treat it like transit.
                    const cid = g.gCluster[gi];
                    if (cid >= 0) {
                        g.gOrbitPhase[gi] += dt * g.gOrbitSpeed[gi];
                        const cx = g.clustersTheta[cid];
                        const cy = g.clustersPhi[cid];
                        const a = g.gOrbitPhase[gi];
                        // "More or less circles": small ellipse in (theta,phi) plane.
                        g.gAnchorTheta[gi] = wrapAngle(cx + Math.cos(a) * g.gOrbitRTheta[gi]);
                        g.gAnchorPhi[gi] = clampPhi(cy + Math.sin(a) * g.gOrbitRPhi[gi]);
                    }

                    if (g.gTimer[gi] <= 0) {
                        g.gState[gi] = STATE_TRANSIT;
                        if (isExiting) {
                            // Keep leaving; don't pick a new venue target.
                            buildSegmentTo(ENTRANCE_THETA, ENTRANCE_PHI);
                        } else {
                            pickNewTarget();
                        }
                    }
                } else {
                    // Follow the segment with eased parameter.
                    g.gTimer[gi] -= dt;
                    const dur = Math.max(1e-6, g.gSegDur[gi]);
                    const u = clamp01(1.0 - g.gTimer[gi] / dur);
                    // Smoothstep easing
                    const uu = u * u * (3.0 - 2.0 * u);

                    const omt = 1.0 - uu;
                    const omt2 = omt * omt;
                    const uu2 = uu * uu;
                    const b0 = omt2 * omt;
                    const b1 = 3.0 * omt2 * uu;
                    const b2 = 3.0 * omt * uu2;
                    const b3 = uu2 * uu;

                    const thU =
                        b0 * g.gTheta0U[gi] +
                        b1 * g.gC1ThetaU[gi] +
                        b2 * g.gC2ThetaU[gi] +
                        b3 * g.gTheta3U[gi];
                    const ph =
                        b0 * g.gPhi0[gi] +
                        b1 * g.gC1Phi[gi] +
                        b2 * g.gC2Phi[gi] +
                        b3 * g.gPhi3[gi];

                    // Smooth per-group meander (like people not walking laser-straight).
                    // Offset is zero at endpoints (sin(pi*u)) so paths connect cleanly.
                    const dThSeg = (g.gTheta3U[gi] - g.gTheta0U[gi]);
                    const dPhSeg = (g.gPhi3[gi] - g.gPhi0[gi]);
                    const distSeg = Math.max(1e-6, Math.sqrt(dThSeg * dThSeg + dPhSeg * dPhSeg));
                    const vx = dThSeg / distSeg;
                    const vy = dPhSeg / distSeg;
                    const px = -vy;
                    const py = vx;
                    const env = Math.sin(Math.PI * uu); // 0..1..0
                    const wob = Math.sin(uu * Math.PI * 2.0 * g.gMeanderFreq[gi] + g.gMeanderPhase[gi]);
                    const amp = g.gMeanderAmp[gi] * env * wob;

                    g.gAnchorTheta[gi] = wrapAngle(thU + px * amp);
                    g.gAnchorPhi[gi] = clampPhi(ph + py * amp);

                    // Tiny wander while in transit so paths feel less robotic.
                    g.gAnchorTheta[gi] = wrapAngle(g.gAnchorTheta[gi] + randn() * 0.0006);
                    g.gAnchorPhi[gi] = clampPhi(g.gAnchorPhi[gi] + randn() * 0.0004);

                    // Arrive -> linger
                    if (g.gTimer[gi] <= 0) {
                        g.gAnchorTheta[gi] = wrapAngle(g.gTheta3U[gi]);
                        g.gAnchorPhi[gi] = clampPhi(g.gPhi3[gi]);
                        // If we just arrived at the entrance during exit window, mark exited.
                        const nearEntrance =
                            Math.abs(angleDelta(g.gAnchorTheta[gi], ENTRANCE_THETA)) < 0.06 &&
                            Math.abs(g.gAnchorPhi[gi] - ENTRANCE_PHI) < 0.05;
                        if (t >= g.gEndTime[gi] && nearEntrance) {
                            g.gExited[gi] = 1;
                            g.gState[gi] = STATE_EXITED;
                        } else {
                            g.gCluster[gi] = g.gTargetCluster[gi];
                            g.gState[gi] = STATE_LINGER;
                            // Linger duration depends on activity
                            // Minutes-long dwell time in sub-venues (reads like crowd gathering).
                            g.gTimer[gi] = (4.0 + (1.0 - g.gAct[gi]) * 14.0 + Math.random() * 6.0) * 60.0;
                            g.gHasSettled[gi] = 1;
                            // When arriving at a sub-venue, re-seed orbit params so each stop feels different.
                            g.gOrbitPhase[gi] = Math.random() * Math.PI * 2;
                            g.gOrbitSpeed[gi] = (0.18 + Math.random() * 0.62) * (Math.random() < 0.25 ? 0.45 : 1.0);
                            g.gOrbitRTheta[gi] = 0.010 + Math.pow(Math.random(), 1.5) * 0.060;
                            g.gOrbitRPhi[gi] = 0.008 + Math.pow(Math.random(), 1.5) * 0.045;
                        }
                    }
                }
            }

            // Snapshot previous positions (for line segments)
            g.prevPos.set(posAttr.array);

            // Update individual stars (follow their group anchor with slight offset)
            for (let i = 0; i < g.theta.length; i++) {
                const gi = g.groupId[i];
                // If this group exited, stop drawing its stars (prevents a bright "entrance blob").
                if (g.gExited[gi] === 1) {
                    colAttr.array[i * 3 + 0] = 0;
                    colAttr.array[i * 3 + 1] = 0;
                    colAttr.array[i * 3 + 2] = 0;
                    continue;
                }
                const desiredTheta = wrapAngle(g.gAnchorTheta[gi] + g.offTheta[i]);
                const desiredPhi = clampPhi(g.gAnchorPhi[gi] + g.offPhi[i]);

                const spring = 0.75;
                const dTh = angleDelta(g.theta[i], desiredTheta);
                const dPh = desiredPhi - g.phi[i];

                // Tiny personal jitter (shuffling feet)
                // Reduced: high-frequency per-star jitter makes “dotty / hairy” trails in timelapse.
                const j = 0.0;
                const ja = 0.0;
                const jb = 0.0;

                g.theta[i] = wrapAngle(g.theta[i] + (dTh * spring + ja) * dt);
                g.phi[i] = clampPhi(g.phi[i] + (dPh * spring + jb) * dt);

                if (g.phi[i] < 0.02) g.phi[i] = 0.02;
                if (g.phi[i] > DOME_PHI_MAX) g.phi[i] = DOME_PHI_MAX;

                const p = sphericalToCartesian(g.theta[i], g.phi[i], g.radius);
                posAttr.array[i * 3 + 0] = p.x;
                posAttr.array[i * 3 + 1] = p.y + CAMERA_EYE_HEIGHT;
                posAttr.array[i * 3 + 2] = p.z;

                // Continuous segment from previous->current (fills “dotted” gaps)
                const px = g.prevPos[i * 3 + 0];
                const py = g.prevPos[i * 3 + 1];
                const pz = g.prevPos[i * 3 + 2];
                linePosAttr.array[i * 6 + 0] = px;
                linePosAttr.array[i * 6 + 1] = py;
                linePosAttr.array[i * 6 + 2] = pz;
                linePosAttr.array[i * 6 + 3] = p.x;
                linePosAttr.array[i * 6 + 4] = p.y + CAMERA_EYE_HEIGHT;
                linePosAttr.array[i * 6 + 5] = p.z;

                // Twinkle
                const tw = 0.04 * Math.sin(t * g.twinkleSpd[i] + g.twinklePhase[i]);
                const bright = clamp01(g.baseB[i] + tw);
                colAttr.array[i * 3 + 0] = g.baseColors[i * 3 + 0] * bright;
                colAttr.array[i * 3 + 1] = g.baseColors[i * 3 + 1] * bright;
                colAttr.array[i * 3 + 2] = g.baseColors[i * 3 + 2] * bright;
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            linePosAttr.needsUpdate = true;
        }

        function sphericalToCartesian(theta, phi, r) {
            const sinPhi = Math.sin(phi);
            return new THREE.Vector3(r * sinPhi * Math.cos(theta), r * Math.cos(phi), r * sinPhi * Math.sin(theta));
        }

        function clamp01(x) { return Math.max(0, Math.min(1, x)); }
        function clampPhi(p) { return Math.max(0.02, Math.min(DOME_PHI_MAX, p)); }
        function wrapAngle(a) { const twoPi = Math.PI * 2; a = a % twoPi; return a < 0 ? a + twoPi : a; }
        function angleDelta(from, to) { let d = (to - from) % (Math.PI * 2); if (d > Math.PI) d -= Math.PI * 2; if (d < -Math.PI) d += Math.PI * 2; return d; }
        function randRange(a, b) { return a + Math.random() * (b - a); }

        function initVenues() {
            // Keep venues in a horizon-ish band so they read like “around the room”.
            const phiMin = 1.35;
            const phiMax = Math.min(DOME_PHI_MAX - 0.12, 2.10);
            const twoPi = Math.PI * 2;

            for (let c = 0; c < CLUSTER_COUNT; c++) {
                const base = (c / CLUSTER_COUNT) * twoPi;
                VENUE_THETA[c] = wrapAngle(base + randn() * 0.35);
                VENUE_PHI[c] = clampPhi(randRange(phiMin, phiMax) + randn() * 0.06);

                const r = Math.random();
                VENUE_SHAPE[c] = r < 0.62 ? 0 : r < 0.84 ? 1 : 2;
                VENUE_ORIENT[c] = Math.random() * twoPi;
                VENUE_ASPECT[c] = VENUE_SHAPE[c] === 0 ? 1.0 : 2.2 + Math.random() * 3.2;

                // No drift in this version (stable venue rooms).
                VENUE_DRIFT_A[c] = 0.0;
                VENUE_DRIFT_B[c] = 0.0;
            }
        }
        function pickGroupSize() {
            const r = Math.random();
            let acc = 0;
            for (const it of GROUP_SIZE_WEIGHTS) { acc += it.w; if (r <= acc) return it.n; }
            return GROUP_SIZE_WEIGHTS[GROUP_SIZE_WEIGHTS.length - 1].n;
        }
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        // ----------------------------
        // Textures
        // ----------------------------
        function createSkyTexture(w, h) {
            const c = document.createElement("canvas");
            c.width = w;
            c.height = h;
            const ctx = c.getContext("2d", { willReadFrequently: false });

            // Pure black background for clean trails (no color buildup with additive blending)
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, w, h);

            const tex = new THREE.CanvasTexture(c);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function clamp255(x) { return Math.max(0, Math.min(255, x)); }

        function makeStarSpriteTexture() {
            const size = 128;
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext("2d");

            const c = size / 2;
            const grad = ctx.createRadialGradient(c, c, 0, c, c, c);
            grad.addColorStop(0.0, "rgba(255,255,255,1)");
            grad.addColorStop(0.12, "rgba(255,255,255,1)");
            grad.addColorStop(0.26, "rgba(255,255,255,0.72)");
            grad.addColorStop(0.42, "rgba(255,255,255,0.16)");
            grad.addColorStop(1.0, "rgba(255,255,255,0)");

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = false;
            tex.needsUpdate = true;
            return tex;
        }
    </script>
</body>

</html>