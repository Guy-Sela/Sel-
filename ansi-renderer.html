<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANSI Art Renderer</title>
    <style>
        body {
            background-color: #0d0d0d;
            color: #cccccc;
            font-family: Menlo, Monaco, 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden; /* No scrollbars on body */
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #controls {
            padding: 10px;
            border-bottom: 1px dashed #444;
            background: #1a1a1a;
            color: #888;
            flex-shrink: 0;
            z-index: 10;
        }

        #stage {
            flex-grow: 1;
            position: relative; /* Anchor for absolute container */
            width: 100%;
            height: 100%; /* Explicit height */
            overflow: hidden; /* Clip anything outside */
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center;     /* Center vertically */
            padding: 0;
        }

        #art-container {
            font-family: Menlo, Monaco, 'Courier New', monospace;
            white-space: pre;
            font-size: 10px; 
            line-height: 10px;
            background-color: #000;
            padding: 0; 
            border: none;
            
            position: absolute; 
            /* Transform origin center for true centering with scale */
            transform-origin: center center;
            
            /* Color correction handled in JS */
            color: #fff; 
        }
    </style>
</head>
<body>

    <div id="controls">
        <p>Attempting to load <strong>ascii-profile.txt</strong>...</p>
        <label>If it fails, select it manually:</label>
        <input type="file" id="fileInput" accept=".txt">
    </div>

    <div id="stage">
        <div id="art-container">Loading...</div>
    </div>

    <script>
        const container = document.getElementById('art-container');
        const fileInput = document.getElementById('fileInput');

        // --- RESIZE LOGIC ---
        function fitAscii() {
            // ASCII dimensions (approx)
            // 160 chars wide. 128 lines tall.
            const CHARS_WIDTH = 160;
            const LINES_HEIGHT = 128;
            
            // Measure current char size using a temp span
            const measure = document.createElement('span');
            measure.style.visibility = 'hidden';
            measure.style.position = 'absolute';
            measure.style.fontSize = '10px'; // Match CSS
            measure.style.fontFamily = "Menlo, Monaco, 'Courier New', monospace";
            measure.textContent = 'M';
            document.body.appendChild(measure);
            const rect = measure.getBoundingClientRect();
            document.body.removeChild(measure);
            
            const charW = rect.width || 6; 
            const charH = rect.height || 10;
            
            const fullW = CHARS_WIDTH * charW;
            const fullH = LINES_HEIGHT * charH;
            
            // Available space (with minimal padding)
            const padding = 20; // 10px each side
            const availW = window.innerWidth - padding;
            // Subtract controls height if visible, otherwise just some bottom padding
            const controlsH = document.getElementById('controls').offsetParent ? document.getElementById('controls').offsetHeight : 0;
            const availH = window.innerHeight - padding - controlsH;
            
            const scale = Math.min(availW / fullW, availH / fullH);
            
            // Ensure scale is never negative or Infinity
            const safeScale = (scale > 0 && scale < 100) ? scale : 0.1;
            
            container.style.transform = `scale(${safeScale})`;
        }

        window.addEventListener('resize', fitAscii);

        // Regex for ANSI 24-bit color: \x1b[38;2;R;G;Bm
        const ANSI_RGB_REGEX = /\x1b\[38;2;(\d+);(\d+);(\d+)m/g;
        // Regex for ANSI reset: \x1b[0m
        const ANSI_RESET_REGEX = /\x1b\[0m/g;

        function renderAnsi(text) {
            // We need to convert ANSI codes to HTML spans.
            // Strategy: Split by codes or replace?
            // Since we have state (color on/off), simple replacement is trickier if nested,
            // but ANSI usually works as "set current color".
            
            // Let's iterate through the text and build HTML.
            
            let html = '';
            let cursor = 0;
            
            // Combined regex to find next tag
            const pattern = /(\x1b\[38;2;\d+;\d+;\d+m)|(\x1b\[0m)/g;
            let match;
            
            // We'll wrap segments in spans.
            // Current active style
            let activeColor = null;

            let lastIndex = 0;

            while ((match = pattern.exec(text)) !== null) {
                const tag = match[0];
                const index = match.index;

                // Append text before this tag
                if (index > lastIndex) {
                    html += escapeHtml(text.substring(lastIndex, index));
                }

                if (tag === '\x1b[0m') {
                    // Reset
                    if (activeColor) {
                        html += '</span>';
                        activeColor = null;
                    }
                } else {
                    // It's a color tag: \x1b[38;2;R;G;Bm
                    // Extract RGB
                    const rgbMatch = tag.match(/(\d+);(\d+);(\d+)/);
                    if (rgbMatch) {
                        let [_, r, g, b] = rgbMatch;
                        
                        // Convert to Grayscale
                        let gray = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);
                        
                        // Aggressive brightness boost
                        // Map 0-255 input to roughly 70-255 output to ensure visibility against black
                        gray = Math.min(255, Math.floor(gray * 2.1 + 70));
                        
                        // Close previous if open
                        if (activeColor) {
                            html += '</span>';
                        }
                        
                        activeColor = `rgb(${gray},${gray},${gray})`;
                        html += `<span style="color: ${activeColor}">`;
                    }
                }
                
                lastIndex = pattern.lastIndex;
            }

            // Append remaining text
            if (lastIndex < text.length) {
                html += escapeHtml(text.substring(lastIndex));
            }
            
            // Close any remaining span
            if (activeColor) {
                html += '</span>';
            }

            // Start Animation
            fitAscii(); // Resize before showing
            animateTypewriter(html);
        }

        // --- TYPEWRITER ANIMATION LOGIC ---
        
        // We can't just slice the HTML string blindly because we might slice inside a tag.
        // We need to parse the HTML string into a list of "tokens" (text node chars or tags)
        // and reveal them one by one.

        function animateTypewriter(fullHtml) {
            container.innerHTML = ''; // Clear start
            
            // 1. Tokenize the HTML string
            // We want a list where each item is either:
            // - A single character of visible text
            // - A full HTML tag (open or close)
            // - HTML entity (treated as 1 char)
            
            // Regex explanation:
            // <[^>]+>  matches any HTML tag
            // &[^;]+;  matches entities like &lt; or &nbsp;
            // [^<>&]   matches any single regular character
            
            const tokens = fullHtml.match(/<[^>]+>|&[^;]+;|[^<>&]/g) || [];
            
            let i = 0;
            const SPEED = 0; // ms per char (0 is "as fast as browser can render loop", usually < 4ms)
                             // Even 0 might be slow for 160x120 = 19,000 chars. 
                             // We might need to batch update.

            // Optimization: Since there are ~20k chars, one-by-one with setTimeout is too slow.
            // We'll reveal 'batchSize' chars per frame.
            const BATCH_SIZE = 150; 

            // Create a buffer for what is currently displayed
            let currentDisplay = "";
            
            function step() {
                if (i >= tokens.length) return; // Done

                // Run a loop to process BATCH_SIZE tokens, but if we encounter a tag,
                // process it immediately without counting it as a "visible char step"
                // so the animation pace depends on visible content, not hidden markup.
                
                let visibleCharsProcessed = 0;
                
                while (visibleCharsProcessed < BATCH_SIZE && i < tokens.length) {
                    const token = tokens[i];
                    currentDisplay += token;
                    i++;
                    
                    // If it starts with <, it's a tag (invisible), so don't count towards batch
                    // If it starts with &, it's an entity (visible), count it.
                    // Otherwise it's a char, count it.
                    if (!token.startsWith('<')) {
                        visibleCharsProcessed++;
                    }
                }
                
                container.innerHTML = currentDisplay;
                
                // Request next frame
                // using standard loop (requestAnimationFrame is ~60fps)
                requestAnimationFrame(step);
            }

            requestAnimationFrame(step);
        }

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function loadFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                renderAnsi(e.target.result);
            };
            reader.readAsText(file);
        }

        // 1. Try Fetching automatically
        fetch('ascii-profile.txt')
            .then(res => {
                if(!res.ok) throw new Error("Status " + res.status);
                return res.text();
            })
            .then(text => {
                renderAnsi(text);
                document.getElementById('controls').style.display = 'none'; // Hide controls on success
            })
            .catch(err => {
                console.log("Auto-load failed (likely CORS or file missing):", err);
                container.textContent = "Could not auto-load 'ascii-profile.txt'. Please use the file picker above.";
            });

        // 2. Manual Input
        fileInput.addEventListener('change', (e) => {
            if(e.target.files[0]) {
                loadFromFile(e.target.files[0]);
            }
        });
    </script>
</body>
</html>
