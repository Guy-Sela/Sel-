<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Selà — Terminal + ANSI</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400&family=Roboto+Mono:wght@300;400&family=Josefin+Sans:wght@300;400&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --panel: rgba(0, 0, 0, 0.45);
      --border: rgba(255, 255, 255, 0.12);
      --text: rgba(255, 255, 255, 0.92);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Josefin Sans', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display: grid;
      place-items: center;
      padding: 18px;
    }

    /* Embedded mode (when this page is inside an iframe):
       remove self-centering + padding so the prompt can align with the parent layout. */
    html.embed body {
      padding: 0;
      display: block;
      place-items: unset;
    }

    html.embed .terminal {
      width: 100%;
      height: 100%;
      max-width: none;
      max-height: none;
      border: 0;
      border-radius: 0;
      box-shadow: none;
    }

    html.embed .terminal-body {
      padding: 0;
    }
    .terminal {
      width: min(980px, 92vw);
      height: min(720px, 86vh);
      border: 1px solid var(--border);
      background: var(--panel);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .terminal-body {
      width: 100%;
      height: 100%;
      padding: clamp(18px, 2.5vw, 42px);
      box-sizing: border-box;
      /* Match Session Witness HUD mono */
      font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.01em;
      line-height: 1.7;
      text-align: left;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Prompt + wrapped text alignment */
    .typedline {
      display: grid;
      grid-template-columns: 2ch minmax(0, 1fr);
      align-items: start;
      font-size: clamp(1.0rem, 0.95rem + 0.3vw, 1.1rem);
      flex: 0 0 auto;
    }

    .prompt {
      color: rgba(255, 255, 255, 0.92);
      font-weight: 600;
      user-select: none;
    }

    .line {
      min-width: 0;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    .cursor {
      display: inline;
      color: var(--text);
      font-weight: 700;
      opacity: 0.95;
      vertical-align: baseline;
    }

    .cursor.is-hidden {
      visibility: hidden;
    }

    @keyframes blink {

      0%,
      50% {
        opacity: 1;
      }

      51%,
      100% {
        opacity: 0;
      }
    }

    .cursor.blink {
      animation: blink 1s infinite step-end;
    }

    .fake-tm {
      font-size: 0.72em;
      vertical-align: super;
      letter-spacing: 0.02em;
      opacity: 0.9;
      margin-left: 0.1ch;
    }

    .pop-num {
      white-space: nowrap;
    }

    /* ANSI stage: starts ~3 lines below the typed text */
    .ansi-stage {
      /* ANSI stage: starts a few lines below the typed text */
      margin-top: 1.2em;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
      display: flex;
      /* Always centered for smooth zoom-to-fit scaling */
      align-items: center;
      justify-content: center;
      padding: 0;
      /* Isolate paint from parent (iOS stability, but NOT size containment) */
      contain: layout paint;
    }

    .ansi-art {
      white-space: pre;
      font-family: 'JetBrains Mono', Menlo, Monaco, 'Courier New', monospace;
      font-size: 10px;
      line-height: 10px;
      transform-origin: center center;
      will-change: transform;
      color: #fff;
      overflow: visible;
      /* Prevent iOS text size inflation */
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }

    .ansi-cursor {
      display: inline-block;
      color: #fff;
      font-weight: 700;
      opacity: 0.95;
      width: 1ch;
    }

    .ansi-cursor.blink {
      animation: blink 1s infinite step-end;
    }

    @media (prefers-reduced-motion: reduce) {

      .cursor,
      .ansi-cursor {
        animation: none !important;
      }
    }
  </style>
</head>

<body>
  <div class="terminal" role="region" aria-label="Terminal combined mock">
    <div class="terminal-body">
      <div class="typedline" aria-label="Terminal output">
        <span class="prompt">❯</span>
        <span class="line"><span id="typedText"></span><span id="cursor" class="cursor">_</span></span>
      </div>

      <div class="ansi-stage" aria-label="ANSI portrait stage">
        <div id="ansiArt" class="ansi-art" aria-label="ANSI art"></div>
      </div>
    </div>
  </div>

  <script>
    // If this page is embedded, switch to "embed" layout mode.
    // (Same-origin iframe, so this is safe; standalone view stays unchanged.)
    try {
      if (window.self !== window.top) document.documentElement.classList.add('embed');
    } catch (e) { }

    (function init() {
      const typedText = document.getElementById('typedText');
      const cursor = document.getElementById('cursor');
      const ansiEl = document.getElementById('ansiArt');
      if (!typedText || !cursor || !ansiEl) return;
      const ansiStage = ansiEl.parentElement;
      const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const isEmbed = document.documentElement.classList.contains('embed');
      let started = false;

      // --- HELPER WRAPPERS ---
      function sleep(ms) { return new Promise(r => window.setTimeout(r, ms)); }
      function setCursorVisible(v) { cursor.classList.toggle('is-hidden', !v); }

      function start() {
        if (started) return;
        started = true;
        
        function doStart() {
          if (reduce) runReduce();
          else run().catch(() => { });
        }
        
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(doStart);
        } else {
          doStart();
        }
      }

      // Embedded behavior:
      // show an idle prompt + blinking cursor, then wait for the parent page to tell us to start.
      if (isEmbed && !reduce) {
        typedText.textContent = '';
        ansiEl.textContent = '';
        setCursorVisible(true);
        cursor.classList.add('blink');

        window.__startCombinedTerminal = start;
        window.addEventListener('message', (e) => {
          const d = e && e.data;
          if (d && typeof d === 'object' && d.type === 'START_TERMINAL_ANSI_COMBINED') start();
        });
        return;
      }

      // Standalone (or reduced motion): start immediately.
      start();

      // --- COMPONENT LOGIC ---


      // ------------------------------
      // World population (single ticker, multiple subscribers)
      // ------------------------------
      function initWorldPop() {
        const state = {
          text: '—',
          ready: false,
          readyPromise: null,
          _resolveReady: null,
          _pop: NaN,
          _rate: NaN,
          _timer: null,
          listeners: [],
          subscribe: (fn) => { state.listeners.push(fn); },
          start: () => { },
          stop: () => { }
        };

        state.readyPromise = new Promise((resolve) => { state._resolveReady = resolve; });
        const markReady = () => {
          if (state.ready) return;
          state.ready = true;
          state._resolveReady?.();
          state._resolveReady = null;
        };
        const format = (n) => Number(n).toLocaleString('en-US');

        state.start = () => {
          if (state._timer) return;
          if (!Number.isFinite(state._pop) || !Number.isFinite(state._rate)) return;
          state._timer = window.setInterval(() => {
            state._pop += state._rate;
            state.text = format(Math.floor(state._pop));
            state.listeners.forEach(fn => fn(state.text));
          }, 1000);
        };

        state.stop = () => {
          if (!state._timer) return;
          window.clearInterval(state._timer);
          state._timer = null;
        };

        const url = `https://www.census.gov/popclock/data/population.php/world?_=${Date.now()}`;
        fetch(url, { cache: 'no-store' })
          .then(r => (r.ok ? r.json() : Promise.reject(new Error(String(r.status)))))
          .then(data => {
            state._pop = Number(data?.world?.population);
            state._rate = Number(data?.world?.population_rate);
            if (!Number.isFinite(state._pop) || !Number.isFinite(state._rate)) throw new Error('bad payload');
            state.text = format(Math.floor(state._pop));
            markReady();
          })
          .catch(() => {
            state.text = '8,000,000,000';
            markReady();
          });

        return state;
      }

      // ------------------------------
      // Text typing (120wpm-ish + pauses)
      // ------------------------------
      async function typeInto(container, text, opts = {}) {
        // 120 WPM ~ 600 CPM ~ ~100ms/char
        const min = opts.minDelay ?? 60;
        const max = opts.maxDelay ?? 100;
        const pausePunct = opts.pausePunct ?? 250;
        const pauseNewline = opts.pauseNewline ?? 250;
        const jitter = () => Math.floor(min + Math.random() * (max - min));

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          container.append(ch);
          container.appendChild(cursor);
          if (ch === '\n') await sleep(pauseNewline);
          else if (ch === '.' || ch === '!' || ch === '?') await sleep(pausePunct + 200);
          else if (ch === ',' || ch === ';' || ch === ':') await sleep(pausePunct);
          else await sleep(jitter());
        }
      }

      async function blinkIdle(ms = 3200) {
        cursor.classList.add('blink');
        setCursorVisible(true);
        await sleep(ms);
        cursor.classList.remove('blink');
        setCursorVisible(true);
      }

      // ------------------------------
      // ANSI -> HTML (grayscale + brightened)
      // ------------------------------
      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      function ansiToHtml(text) {
        const pattern = /(\x1b\[38;2;\d+;\d+;\d+m)|(\x1b\[0m)/g;
        let html = '';
        let active = false;
        let lastIndex = 0;
        let match;

        while ((match = pattern.exec(text)) !== null) {
          const tag = match[0];
          const idx = match.index;
          if (idx > lastIndex) html += escapeHtml(text.substring(lastIndex, idx));

          if (tag === '\x1b[0m') {
            if (active) {
              html += '</span>';
              active = false;
            }
          } else {
            const rgbMatch = tag.match(/(\d+);(\d+);(\d+)/);
            if (rgbMatch) {
              const r = Number(rgbMatch[1]);
              const g = Number(rgbMatch[2]);
              const b = Number(rgbMatch[3]);

              // grayscale + brightness boost
              let gray = Math.floor(0.299 * r + 0.587 * g + 0.114 * b);
              gray = Math.min(255, Math.floor(gray * 2.4 + 95));

              if (active) html += '</span>';
              html += `<span style="color: rgb(${gray},${gray},${gray})">`;
              active = true;
            }
          }

          lastIndex = pattern.lastIndex;
        }

        if (lastIndex < text.length) html += escapeHtml(text.substring(lastIndex));
        if (active) html += '</span>';
        return html;
      }

      // ------------------------------
      // Fit ANSI art in its box (font-size based, not transform)
      // ------------------------------
      function alignAnsiToTextColumn(centered) {
        // Always centered now for smooth zoom-to-fit
        if (ansiStage) ansiStage.classList.add('ansi-centered');
      }

      function computeAnsiFitScale() {
        const stage = ansiStage || ansiEl.parentElement;
        if (!stage) return 0.2;
        const pad = 16;
        const availW = Math.max(120, stage.clientWidth - pad);
        const availH = Math.max(120, stage.clientHeight - pad);

        // Measure using a temp span matching ansiEl font.
        const meas = document.createElement('span');
        meas.style.position = 'absolute';
        meas.style.visibility = 'hidden';
        meas.style.fontFamily = getComputedStyle(ansiEl).fontFamily;
        meas.style.fontSize = getComputedStyle(ansiEl).fontSize;
        meas.textContent = 'M';
        document.body.appendChild(meas);
        const m = meas.getBoundingClientRect();
        meas.remove();
        const cw = m.width || 7;
        const ch = m.height || 12;

        // Estimate dimensions from plain-text version (strip tags).
        const plain = ansiEl.textContent || '';
        const lines = plain.split('\n');
        const cols = Math.max(1, ...lines.map(l => l.length)) + 1;
        const rows = Math.max(1, lines.length);

        const fullW = cols * cw;
        const fullH = rows * ch;
        const scale = Math.min(availW / fullW, availH / fullH, 1);
        const safe = Math.max(0, Math.min(1, scale * 0.95));
        return (safe > 0 && safe < 100) ? safe : 0.2;
      }

      function fitAnsiToScale(scale) {
        ansiEl.style.transform = `scale(${scale})`;
      }

      function forceAnsiCursorBlink() {
        // Ensure the ANSI cursor is blinking at rest by replacing it.
        const c = ansiEl.querySelector('.ansi-cursor');
        if (!c) return;
        const newCursor = document.createElement('span');
        newCursor.className = 'ansi-cursor blink';
        newCursor.textContent = '_';
        c.parentNode.replaceChild(newCursor, c);
      }

      // Debounced resize: avoid iOS scroll-triggered jitter from URL bar changes.
      // visualViewport resize is intentionally NOT listened to — it fires mid-scroll on iOS.
      let resizeTimer = 0;
      window.addEventListener('resize', () => {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          resizeTimer = 0;
          const s = computeAnsiFitScale();
          if (typeof s === 'number') fitAnsiToScale(s);
        }, 150);
      }, { passive: true });

      // ------------------------------
      // ANSI animation:
      // - wait a few seconds after text finishes
      // - start ~120wpm pace with pauses
      // - after some time, ramp into ~200 visible chars/frame
      // ------------------------------
      function tokenizeHtml(fullHtml) {
        return fullHtml.match(/<[^>]+>|&[^;]+;|[^<>&]/g) || [];
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - Math.max(0, Math.min(1, t)), 3);
      }

      function countVisible(tokens) {
        let n = 0;
        for (const t of tokens) if (!t.startsWith('<')) n++;
        return n;
      }

      async function animateAnsi(fullHtml, finalScale) {
        ansiEl.innerHTML = '';
        const ANSI_CURSOR_HTML = '<span class="ansi-cursor blink">_</span>';
        const tokens = tokenizeHtml(fullHtml);
        let i = 0;
        let current = '';

        // Always keep it centered so nothing ever jumps
        alignAnsiToTextColumn(true);

        // Get stage dimensions for continuous fit calculation
        const stage = ansiStage || ansiEl.parentElement;
        const pad = 16;
        const availW = Math.max(100, (stage?.clientWidth || 300) - pad);
        const availH = Math.max(100, (stage?.clientHeight || 400) - pad);

        // Measure char dimensions
        const meas = document.createElement('span');
        meas.style.fontFamily = getComputedStyle(ansiEl).fontFamily;
        meas.style.fontSize = getComputedStyle(ansiEl).fontSize;
        meas.style.visibility = 'hidden';
        meas.style.position = 'absolute';
        meas.textContent = 'M';
        document.body.appendChild(meas);
        const cw = meas.getBoundingClientRect().width || 7;
        const ch = meas.getBoundingClientRect().height || 12;
        meas.remove();

        // Track content dimensions as we draw
        let maxCols = 1;
        let currentCol = 0;
        let rows = 1;

        // Compute scale to fit current content (only shrink when needed)
        function computeLiveScale() {
          const contentW = (maxCols + 2) * cw;
          const contentH = rows * ch;
          const scaleW = availW / contentW;
          const scaleH = availH / contentH;
          return Math.min(1, scaleW, scaleH);
        }

        const stage1MaxVisible = 100;
        let visibleCount = 0;
        const speed120 = { minDelay: 60, maxDelay: 100 };
        const pauseMarks = new Set([18, 45, 72]);

        // Stage 1: human pace
        while (i < tokens.length && visibleCount < stage1MaxVisible) {
          const t = tokens[i++];
          current += t;

          // Track dimensions
          if (!t.startsWith('<')) {
            if (t === '\n') {
              rows++;
              currentCol = 0;
            } else {
              currentCol++;
              if (currentCol > maxCols) maxCols = currentCol;
            }
          }

          ansiEl.innerHTML = current + ANSI_CURSOR_HTML;

          if (!t.startsWith('<')) {
            visibleCount++;
            // Continuously fit as we go
            fitAnsiToScale(computeLiveScale());

            if (pauseMarks.has(visibleCount)) {
              await sleep(400 + Math.floor(Math.random() * 500));
            }
            const baseDelay = Math.floor(speed120.minDelay + Math.random() * (speed120.maxDelay - speed120.minDelay));
            await sleep(t === '\n' ? 8 : baseDelay);
          }
        }

        // Stage 2: ramp up batch size
        let batch = 8;
        const maxBatch = 1000;
        const ramp = 60;

        return new Promise((resolve) => {
          function step() {
            if (i >= tokens.length) {
              ansiEl.innerHTML = current + ANSI_CURSOR_HTML;
              forceAnsiCursorBlink();
              fitAnsiToScale(finalScale);
              resolve();
              return;
            }

            let visibleProcessed = 0;
            while (i < tokens.length && visibleProcessed < batch) {
              const t = tokens[i++];
              current += t;
              if (!t.startsWith('<')) {
                if (t === '\n') {
                  rows++;
                  currentCol = 0;
                } else {
                  currentCol++;
                  if (currentCol > maxCols) maxCols = currentCol;
                }
                visibleProcessed++;
              }
            }
            ansiEl.innerHTML = current + ANSI_CURSOR_HTML;
            fitAnsiToScale(computeLiveScale());

            batch = Math.min(maxBatch, batch + ramp);
            requestAnimationFrame(step);
          }
          requestAnimationFrame(step);
        });
      }

      function runReduce() {
        // Minimal static render for reduced motion
        typedText.textContent = 'Born 1977, Israel. On a good day, one in —. On a bad day, one of —. Code for consciousness';
        const tm = document.createElement('span');
        tm.className = 'fake-tm';
        tm.textContent = 'TM';
        typedText.appendChild(tm);
        typedText.appendChild(document.createTextNode('.'));
        setCursorVisible(false);
        fetch('ascii-profile.txt').then(r => r.text()).then(t => {
          ansiEl.innerHTML = ansiToHtml(t);
          const finalScale = computeAnsiFitScale() ?? 0.2;
          fitAnsiToScale(finalScale);
        }).catch(() => { });
      }

      async function run() {
        if (reduce) return;
        const wp = initWorldPop();
        ansiEl.textContent = ''; // keep blank until we start
        setCursorVisible(true);
        // Idle cursor blink before any typing begins (About section prelude).
        await blinkIdle(5000);

        const speed120 = { minDelay: 60, maxDelay: 100, pausePunct: 250 };

        await typeInto(typedText, 'Born 1977, Israel.', speed120);
        await sleep(1300);
        await typeInto(typedText, ' On a good day, one in ', speed120);

        const popSpan1 = document.createElement('span');
        popSpan1.className = 'pop-num';
        typedText.appendChild(popSpan1);

        await Promise.race([wp.readyPromise, sleep(2000)]);
        const initialVal = wp.text;
        await typeInto(popSpan1, initialVal, { minDelay: 80, maxDelay: 120, pausePunct: 240 });
        typedText.appendChild(cursor);
        wp.subscribe((val) => { popSpan1.textContent = val; });
        wp.start();

        await typeInto(typedText, '.', speed120);
        await sleep(1150);
        await typeInto(typedText, ' On a bad day, one of ', speed120);

        const popSpan2 = document.createElement('span');
        popSpan2.className = 'pop-num';
        typedText.appendChild(popSpan2);

        // Prevent number drift while typing the second counter
        wp.stop();
        const currentVal = wp.text;
        await typeInto(popSpan2, currentVal, { minDelay: 80, maxDelay: 120, pausePunct: 240 });
        typedText.appendChild(cursor);
        wp.subscribe((val) => { popSpan2.textContent = val; });
        wp.start();

        await typeInto(typedText, '.', speed120);
        await sleep(1800);
        await typeInto(typedText, ' Code for Consciousness', speed120);

        const tm = document.createElement('span');
        tm.className = 'fake-tm';
        tm.textContent = 'TM';
        typedText.appendChild(tm);
        typedText.appendChild(cursor);
        await typeInto(typedText, '.', speed120);
        await sleep(3200);

        // Move attention to ANSI: cursor descends line by line
        cursor.classList.remove('blink');
        const lineEl = typedText.parentElement; // .line container
        const descentLines = 3;
        for (let d = 0; d < descentLines; d++) {
          lineEl.appendChild(document.createTextNode('\n'));
          lineEl.appendChild(cursor);
          await sleep(1000);
        }
        setCursorVisible(false);

        // Load ANSI portrait
        let ansiRaw = '';
        try {
          const res = await fetch('ascii-profile.txt', { cache: 'no-store' });
          if (!res.ok) throw new Error(String(res.status));
          ansiRaw = await res.text();
        } catch (e) {
          ansiEl.textContent = 'Could not load ascii-profile.txt';
          return;
        }

        const html = ansiToHtml(ansiRaw);

        // Always centered from the start for smooth scaling
        alignAnsiToTextColumn(true);

        // Set a quick plain text snapshot for sizing; actual HTML comes during animation.
        ansiEl.textContent = ansiRaw.replace(/\x1b\[[0-9;]*m/g, '').replace(/\r/g, '');
        const finalScale = computeAnsiFitScale() ?? 0.2;

        // Suspense prelude: show only the ANSI cursor for a moment, then begin drawing.
        ansiEl.innerHTML = '<span class="ansi-cursor blink">_</span>';
        await sleep(900);
        await sleep(520);

        // Now animate the actual colored HTML
        await animateAnsi(html, finalScale);
        fitAnsiToScale(finalScale);
      }
    })();
  </script>
</body>

</html>