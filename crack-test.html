<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glass Crack Effect</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      overflow: hidden;
      cursor: crosshair;
    }

    canvas {
      display: block;
    }

    .hint {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.3);
      font-family: system-ui, sans-serif;
      font-size: 0.875rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <p class="hint">Hold longer = stronger crack</p>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redraw();
    }

    // Store all cracks
    const allCracks = [];

    // Track click power via hold duration
    let mouseDownTime = 0;
    const MAX_HOLD = 1000; // Max 1 second for full power

    // Crack class
    class Crack {
      constructor(x, y, power = 1) {
        this.origin = { x, y };
        this.power = power; // 0.1 to 1
        this.lines = [];
        this.generateCrack();
      }

      generateCrack() {
        // Number of branches scales with power (3-10 branches)
        const branches = Math.floor(this.power * 7) + 3;

        for (let i = 0; i < branches; i++) {
          const angle = (Math.PI * 2 / branches) * i + (Math.random() - 0.5) * 0.5;
          this.createBranch(this.origin.x, this.origin.y, angle, 1, 0);
        }
      }

      createBranch(x, y, angle, generation, depth) {
        if (depth > 4 || generation > 5) return;

        // Length scales with power
        const baseLength = (Math.random() * 80 + 40) * this.power;
        const length = baseLength / generation;
        const segments = Math.floor(Math.random() * 3) + 2;

        let currentX = x;
        let currentY = y;
        let currentAngle = angle;

        for (let i = 0; i < segments; i++) {
          currentAngle += (Math.random() - 0.5) * 0.4;

          const segmentLength = length / segments;
          const endX = currentX + Math.cos(currentAngle) * segmentLength;
          const endY = currentY + Math.sin(currentAngle) * segmentLength;

          this.lines.push({
            x1: currentX,
            y1: currentY,
            x2: endX,
            y2: endY,
            width: Math.max(0.5, 2 - generation * 0.3)
          });

          if (Math.random() < 0.4 && generation < 4) {
            const branchAngle = currentAngle + (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.8 + 0.3);
            this.createBranch(endX, endY, branchAngle, generation + 1, depth + 1);
          }

          currentX = endX;
          currentY = endY;
        }

        if (Math.random() < 0.7 && generation < 3) {
          this.createBranch(currentX, currentY, currentAngle + (Math.random() - 0.5) * 0.3, generation, depth + 1);
        }
      }

      // Extend crack from its endpoints
      extend(amount) {
        const endpoints = this.getEndpoints();
        const extensionsToAdd = [];

        endpoints.forEach(ep => {
          if (Math.random() < amount) {
            const angle = ep.angle + (Math.random() - 0.5) * 0.6;
            const length = (Math.random() * 30 + 15) * amount;
            const endX = ep.x + Math.cos(angle) * length;
            const endY = ep.y + Math.sin(angle) * length;

            extensionsToAdd.push({
              x1: ep.x,
              y1: ep.y,
              x2: endX,
              y2: endY,
              width: Math.max(0.3, ep.width * 0.8)
            });
          }
        });

        this.lines.push(...extensionsToAdd);
      }

      // Get crack endpoints for extension
      getEndpoints() {
        const endpoints = [];
        const endCounts = {};

        // Count how many times each point appears
        this.lines.forEach(line => {
          const key1 = `${line.x2.toFixed(1)},${line.y2.toFixed(1)}`;
          endCounts[key1] = (endCounts[key1] || 0) + 1;
        });

        // Find true endpoints (appear only once as an end)
        this.lines.forEach(line => {
          const key = `${line.x2.toFixed(1)},${line.y2.toFixed(1)}`;
          if (endCounts[key] === 1) {
            const angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
            endpoints.push({ x: line.x2, y: line.y2, angle, width: line.width });
          }
        });

        return endpoints;
      }

      draw(ctx) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineCap = 'round';

        this.lines.forEach(line => {
          ctx.beginPath();
          ctx.lineWidth = line.width;
          ctx.moveTo(line.x1, line.y1);
          ctx.lineTo(line.x2, line.y2);
          ctx.stroke();
        });

        // Draw impact point
        ctx.beginPath();
        ctx.arc(this.origin.x, this.origin.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fill();
      }
    }

    // Calculate distance between point and crack
    function distanceToCrack(x, y, crack) {
      return Math.hypot(x - crack.origin.x, y - crack.origin.y);
    }

    // Extend nearby cracks based on distance
    function extendNearbyCracks(x, y, power) {
      const maxInfluenceRadius = 300;

      allCracks.forEach(crack => {
        const dist = distanceToCrack(x, y, crack);
        if (dist < maxInfluenceRadius && dist > 10) {
          // Inverse distance: closer = more extension
          const influence = (1 - dist / maxInfluenceRadius) * power;
          crack.extend(influence);
        }
      });
    }

    // Redraw all cracks
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      allCracks.forEach(crack => crack.draw(ctx));
    }

    // Mouse/touch handlers for power measurement
    canvas.addEventListener('mousedown', (e) => {
      mouseDownTime = Date.now();
    });

    canvas.addEventListener('mouseup', (e) => {
      const holdDuration = Date.now() - mouseDownTime;
      const power = Math.min(holdDuration / MAX_HOLD, 1) * 0.7 + 0.3; // 0.3 to 1

      // Extend existing cracks first
      extendNearbyCracks(e.clientX, e.clientY, power);

      // Create new crack
      const crack = new Crack(e.clientX, e.clientY, power);
      allCracks.push(crack);
      redraw();
    });

    // Touch support with force (if available)
    canvas.addEventListener('touchend', (e) => {
      const touch = e.changedTouches[0];
      // Use force if available (0-1), otherwise default
      const power = touch.force > 0 ? touch.force : 0.7;

      extendNearbyCracks(touch.clientX, touch.clientY, power);
      const crack = new Crack(touch.clientX, touch.clientY, power);
      allCracks.push(crack);
      redraw();
      e.preventDefault();
    });

    // Resize handler
    window.addEventListener('resize', resize);

    // Initial setup
    resize();
  </script>
</body>

</html>