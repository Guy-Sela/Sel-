<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Plot Thickens — Lens + Parallax (Timelapse, Single Person)</title>
  <style>
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    canvas {
      display: block;
    }

    .hud {
      position: fixed;
      left: 16px;
      top: 14px;
      color: rgba(255, 255, 255, 0.78);
      font-size: 13px;
      line-height: 1.35;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 12px rgba(0, 0, 0, 0.85);
      white-space: pre;
    }

    .hint {
      position: fixed;
      left: 16px;
      bottom: 14px;
      color: rgba(255, 255, 255, 0.62);
      font-size: 12px;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 12px rgba(0, 0, 0, 0.85);
    }
  </style>
</head>

<body>
  <div class="hud" id="hud"></div>
  <div class="hint">Single person narrative. Drag to look. Space: pause. R: reset. ↑/↓ or +/-: time scale. [ / ]: trail
    length.</div>
  <div id="error-msg"
    style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(50,0,0,0.9); padding:20px; color:white; display:none; z-index:9999; max-width:80%;">
  </div>

  <script>
    window.onerror = function (msg, url, line) {
      const el = document.getElementById('error-msg');
      el.style.display = 'block';
      el.innerHTML = "Error: " + msg + "<br><small>" + url + ":" + line + "</small><br><br>If THREE is not defined, check your internet connection or ad blocker.";
    };
  </script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";

    // ----------------------------
    // Intent: single-person narrative
    // ----------------------------
    // Person enters -> goes to venue 1 -> circles/lingers -> goes to venue 2 -> ... -> venue 5 -> exit.
    // The trail buffer is the "long exposure" that reveals the path.

    // ----------------------------
    // Base scene constants
    // ----------------------------
    const DOME_RADIUS = 10;
    const CAMERA_EYE_HEIGHT = 1.55;
    const DOME_PHI_MAX = Math.PI * 0.86;

    // Entrance (bottom) in spherical coordinates.
    const ENTRANCE_THETA = Math.PI * 1.5; // forward (-Z)
    const ENTRANCE_PHI = 1.95; // bottom-ish, still visible
    const ENTRANCE_SPREAD_THETA = 0.08;
    const ENTRANCE_SPREAD_PHI = 0.03;

    // Event duration
    const SIM_DURATION = 3 * 60 * 60; // 3 hours

    // 5 sub-venues ("constellations") scattered around the horizon band.
    const VENUE_COUNT = 5;
    const VENUE_THETA = new Float32Array(VENUE_COUNT);
    const VENUE_PHI = new Float32Array(VENUE_COUNT);
    const VENUE_SHAPE = new Int8Array(VENUE_COUNT); // 0=blob, 1=line, 2=arc (for static stars)
    const VENUE_ORIENT = new Float32Array(VENUE_COUNT);
    const VENUE_ASPECT = new Float32Array(VENUE_COUNT);

    // Static "night sky" backdrop (clusters centered on venues)
    const STAR_COUNT = 6500;
    const CLUSTER_FRACTION = 0.78;
    const CLUSTER_SIGMA_THETA = 0.060;
    const CLUSTER_SIGMA_PHI = 0.045;
    const STAR_LAYERS = [
      { fraction: 0.56, size: 0.007 },
      { fraction: 0.26, size: 0.011 },
      { fraction: 0.13, size: 0.018 },
      { fraction: 0.05, size: 0.030 }
    ];

    // Parallax shells
    const STAR_SHELLS = [
      { fraction: 0.22, radiusMul: 0.86 },  // near
      { fraction: 0.34, radiusMul: 0.93 },  // mid
      { fraction: 0.44, radiusMul: 0.995 }  // far
    ];
    const PARALLAX_STRENGTH = 1.0;

    // Lens (Option C)
    const LENS_DISTORT = 0.11;
    const LENS_VIGNETTE = 0.35;
    const LENS_SHARPNESS = 0.88;

    // Trails
    let TRAIL_DECAY = 0.997;
    const MAX_SIM_STEP = 0.04;
    const MAX_SUBSTEPS = 32;
    const MIN_SUBSTEPS = 4;

    // Timelapse controls
    let isPaused = false;
    let timeScale = 60.0; // you can change with ↑/↓
    const MOTION_SCALE = 0.02;
    let simTime = 0;

    // Person motion tuning
    // (theta/phi are in radians; these rates create minutes-long motions at default timeScale)
    const WALK_SPEED = 0.0000020; // base for transit duration calculation
    const ORBIT_R_THETA = [0.020, 0.060];
    const ORBIT_R_PHI = [0.015, 0.045];
    const ORBIT_SPEED = [0.18, 0.55]; // rad/sec of sim time (phase)
    const LINGER_MIN = 12 * 60; // 12 min
    const LINGER_MAX = 28 * 60; // 28 min

    const hudEl = document.getElementById("hud");

    // ----------------------------
    // Scene setup
    // ----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.05, 200);
    camera.position.set(0, CAMERA_EYE_HEIGHT, 0);
    camera.lookAt(0, CAMERA_EYE_HEIGHT + 0.4, -1);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);
    document.body.tabIndex = 0;
    renderer.domElement.tabIndex = 0;
    renderer.domElement.style.outline = "none";
    try { renderer.domElement.focus(); } catch (_) { }

    // Dome backdrop (solid black, but keeps inside/dome feel)
    const skyTex = createSkyTexture(1024, 512);
    skyTex.wrapS = THREE.RepeatWrapping;
    skyTex.wrapT = THREE.ClampToEdgeWrapping;
    skyTex.anisotropy = 4;
    const domeGeo = new THREE.SphereGeometry(DOME_RADIUS, 64, 48, 0, Math.PI * 2, 0, DOME_PHI_MAX);
    const domeMat = new THREE.MeshBasicMaterial({ side: THREE.BackSide, map: skyTex, transparent: false });
    const dome = new THREE.Mesh(domeGeo, domeMat);
    dome.position.y = CAMERA_EYE_HEIGHT;
    dome.renderOrder = -10;
    domeMat.depthWrite = false;
    scene.add(dome);

    // Init venues and stars
    initVenues();
    const STAR_SPRITE_TEX = makeStarSpriteTexture();
    const starGroups = [];
    buildStaticStars();
    starGroups.forEach(g => scene.add(g));

    // ----------------------------
    // Person (single agent) states (must be defined before createPerson() is called)
    // ----------------------------
    const STATE_WAIT = 0;
    const STATE_TRANSIT = 1;
    const STATE_LINGER = 2;
    const STATE_EXITING = 3;
    const STATE_EXITED = 4;

    // Person (single)
    const person = createPerson();
    scene.add(person.points);
    scene.add(person.seg); // short segment for "ink" deposit per frame

    // ----------------------------
    // Post: lens distortion + vignette + accumulation trails
    // ----------------------------
    const post = {
      sceneRT: new THREE.WebGLRenderTarget(1, 1, { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, depthBuffer: true, stencilBuffer: false }),
      warpRT: new THREE.WebGLRenderTarget(1, 1, { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, depthBuffer: false, stencilBuffer: false }),
      accumA: new THREE.WebGLRenderTarget(1, 1, { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, depthBuffer: false, stencilBuffer: false }),
      accumB: new THREE.WebGLRenderTarget(1, 1, { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, depthBuffer: false, stencilBuffer: false }),
      scene: new THREE.Scene(),
      cam: new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1),
      mat: null,
      trailMat: null,
      blitMat: null,
      accumFlip: false
    };

    post.mat = new THREE.ShaderMaterial({
      depthTest: false,
      depthWrite: false,
      uniforms: {
        tScene: { value: post.sceneRT.texture },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        k: { value: LENS_DISTORT },
        vignette: { value: LENS_VIGNETTE },
        sharpness: { value: LENS_SHARPNESS }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform sampler2D tScene;
        uniform vec2 resolution;
        uniform float k;
        uniform float vignette;
        uniform float sharpness;
        varying vec2 vUv;

        float smoothstep01(float a, float b, float x) {
          float t = clamp((x - a) / (b - a), 0.0, 1.0);
          return t * t * (3.0 - 2.0 * t);
        }

        void main() {
          vec2 uv = vUv;
          vec2 c = vec2(0.5);
          vec2 d = uv - c;
          float r2 = dot(d, d);
          vec2 warped = c + d * (1.0 + k * r2);

          // Fade out instead of clamping to avoid edge streaks.
          vec2 q = abs(warped - c) * 2.0;
          float edge = max(q.x, q.y);
          float edgeMask = smoothstep01(1.04, 0.98, edge);

          vec3 col = texture2D(tScene, warped).rgb * edgeMask;
          float r = sqrt(r2) / 0.7071;
          float vig = smoothstep01(1.0, sharpness, r);
          col *= mix(1.0, vig, vignette);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    const warpQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), post.mat);
    post.scene.add(warpQuad);

    post.trailMat = new THREE.ShaderMaterial({
      depthTest: false,
      depthWrite: false,
      uniforms: {
        tPrev: { value: post.accumA.texture },
        tCurr: { value: post.warpRT.texture },
        decay: { value: TRAIL_DECAY },
        texel: { value: new THREE.Vector2(1 / Math.max(1, window.innerWidth), 1 / Math.max(1, window.innerHeight)) }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform sampler2D tPrev;
        uniform sampler2D tCurr;
        uniform float decay;
        uniform vec2 texel;
        varying vec2 vUv;
        void main() {
          vec3 prev = texture2D(tPrev, vUv).rgb;
          vec3 c0 = texture2D(tCurr, vUv).rgb;
          vec3 c1 = texture2D(tCurr, vUv + vec2(texel.x, 0.0)).rgb;
          vec3 c2 = texture2D(tCurr, vUv + vec2(-texel.x, 0.0)).rgb;
          vec3 c3 = texture2D(tCurr, vUv + vec2(0.0, texel.y)).rgb;
          vec3 c4 = texture2D(tCurr, vUv + vec2(0.0, -texel.y)).rgb;
          vec3 c5 = texture2D(tCurr, vUv + vec2(texel.x, texel.y)).rgb;
          vec3 c6 = texture2D(tCurr, vUv + vec2(-texel.x, texel.y)).rgb;
          vec3 c7 = texture2D(tCurr, vUv + vec2(texel.x, -texel.y)).rgb;
          vec3 c8 = texture2D(tCurr, vUv + vec2(-texel.x, -texel.y)).rgb;
          vec3 blur = (4.0*c0 + 2.0*(c1+c2+c3+c4) + (c5+c6+c7+c8)) / 16.0;
          vec2 t2 = texel * 2.0;
          vec3 d1 = texture2D(tCurr, vUv + vec2(t2.x, 0.0)).rgb;
          vec3 d2 = texture2D(tCurr, vUv + vec2(-t2.x, 0.0)).rgb;
          vec3 d3 = texture2D(tCurr, vUv + vec2(0.0, t2.y)).rgb;
          vec3 d4 = texture2D(tCurr, vUv + vec2(0.0, -t2.y)).rgb;
          vec3 d5 = texture2D(tCurr, vUv + vec2(t2.x, t2.y)).rgb;
          vec3 d6 = texture2D(tCurr, vUv + vec2(-t2.x, t2.y)).rgb;
          vec3 d7 = texture2D(tCurr, vUv + vec2(t2.x, -t2.y)).rgb;
          vec3 d8 = texture2D(tCurr, vUv + vec2(-t2.x, -t2.y)).rgb;
          vec3 blur2 = (4.0*c0 + (d1+d2+d3+d4) + 0.7*(d5+d6+d7+d8)) / (4.0 + 4.0 + 0.7*4.0);
          vec3 curr = max(c0, mix(blur, blur2, 0.55));
          vec3 col = max(prev * decay, curr);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    post.blitMat = new THREE.ShaderMaterial({
      depthTest: false,
      depthWrite: false,
      uniforms: { t: { value: post.accumA.texture } },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform sampler2D t;
        varying vec2 vUv;
        void main() {
          gl_FragColor = vec4(texture2D(t, vUv).rgb, 1.0);
        }
      `
    });

    // ----------------------------
    // Interaction: drag to look around (yaw/pitch)
    // ----------------------------
    const look = { yaw: 0, pitch: 0.55, targetYaw: 0, targetPitch: 0.55 };
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      try { renderer.domElement.focus(); } catch (_) { }
      renderer.domElement.setPointerCapture(e.pointerId);
      clearAccum();
    });
    renderer.domElement.addEventListener("pointerup", (e) => {
      isDragging = false;
      try { renderer.domElement.releasePointerCapture(e.pointerId); } catch (_) { }
      clearAccum();
    });
    renderer.domElement.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      look.targetYaw += dx * 0.004;
      look.targetPitch += dy * 0.004;
      look.targetPitch = Math.max(-0.05, Math.min(1.25, look.targetPitch));
    });

    const handleKey = (e) => {
      const k = e.key;
      const code = e.code;
      const keyCode = e.keyCode || e.which || 0;
      const kl = (k && k.toLowerCase) ? k.toLowerCase() : k;
      if (k === " " || k === "Spacebar") {
        e.preventDefault();
        isPaused = !isPaused;
      } else if (kl === "r") {
        simTime = 0;
        resetPerson();
        clearAccum();
      } else if (
        k === "ArrowUp" || k === "Up" || code === "ArrowUp" || keyCode === 38 ||
        code === "NumpadAdd" || k === "+" || k === "="
      ) {
        e.preventDefault();
        timeScale = Math.min(600, timeScale * 1.25);
      } else if (
        k === "ArrowDown" || k === "Down" || code === "ArrowDown" || keyCode === 40 ||
        code === "NumpadSubtract" || k === "-" || k === "_"
      ) {
        e.preventDefault();
        timeScale = Math.max(0.1, timeScale / 1.25);
      } else if (k === "[") {
        TRAIL_DECAY = Math.max(0.90, TRAIL_DECAY - 0.005);
        post.trailMat.uniforms.decay.value = TRAIL_DECAY;
      } else if (k === "]") {
        TRAIL_DECAY = Math.min(1.0, TRAIL_DECAY + 0.005);
        post.trailMat.uniforms.decay.value = TRAIL_DECAY;
      }
    };
    window.addEventListener("keydown", handleKey, { passive: false, capture: true });
    document.addEventListener("keydown", handleKey, { passive: false, capture: true });

    // ----------------------------
    // Animate
    // ----------------------------
    const clock = new THREE.Clock();
    let realTime = 0;

    function animate() {
      requestAnimationFrame(animate);

      const dtReal = Math.min(clock.getDelta(), 0.05);
      realTime += dtReal;
      const dtSimTotal = isPaused ? 0 : dtReal * timeScale * MOTION_SCALE;

      look.yaw += (look.targetYaw - look.yaw) * (1 - Math.pow(0.0007, dtReal));
      look.pitch += (look.targetPitch - look.pitch) * (1 - Math.pow(0.0007, dtReal));

      const subSteps = isPaused
        ? 1
        : Math.min(MAX_SUBSTEPS, Math.max(MIN_SUBSTEPS, Math.ceil(dtSimTotal / MAX_SIM_STEP)));
      const dtSim = subSteps > 0 ? dtSimTotal / subSteps : 0;

      for (let s = 0; s < subSteps; s++) {
        if (!isPaused) {
          simTime += dtSim;
          updatePerson(dtSim, simTime);
        }

        // Tiny sway uses REAL time (stable parallax)
        const swayX = (Math.sin(realTime * 0.35) * 0.040 + Math.sin(realTime * 0.11) * 0.018) * PARALLAX_STRENGTH;
        const swayZ = (Math.cos(realTime * 0.29) * 0.030) * PARALLAX_STRENGTH;
        const bobY = Math.sin(realTime * 0.23) * 0.010 * PARALLAX_STRENGTH;
        camera.position.set(swayX, CAMERA_EYE_HEIGHT + bobY, swayZ);

        const dir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(look.pitch, look.yaw, 0, "YXZ"));
        camera.lookAt(camera.position.clone().add(dir));

        // 1) Render 3D scene
        renderer.setRenderTarget(post.sceneRT);
        renderer.render(scene, camera);

        // 2) Lens warp to warpRT
        renderer.setRenderTarget(post.warpRT);
        renderer.render(post.scene, post.cam);

        // 3) Accumulate trails
        const prev = post.accumFlip ? post.accumB : post.accumA;
        const next = post.accumFlip ? post.accumA : post.accumB;
        if (!isPaused && !isDragging) {
          const prevMat = warpQuad.material;
          warpQuad.material = post.trailMat;
          post.trailMat.uniforms.tPrev.value = prev.texture;
          post.trailMat.uniforms.tCurr.value = post.warpRT.texture;
          renderer.setRenderTarget(next);
          renderer.render(post.scene, post.cam);
          warpQuad.material = prevMat;
          post.accumFlip = !post.accumFlip;
        }
      }

      // 4) Blit
      const showTex = isDragging ? post.warpRT.texture : (post.accumFlip ? post.accumB.texture : post.accumA.texture);
      post.blitMat.uniforms.t.value = showTex;
      const prevMat2 = warpQuad.material;
      warpQuad.material = post.blitMat;
      renderer.setRenderTarget(null);
      renderer.render(post.scene, post.cam);
      warpQuad.material = prevMat2;

      hudEl.textContent =
        "The Plot Thickens — single person timelapse\n" +
        `timeScale: ${timeScale.toFixed(2)}×   ${isPaused ? "(paused)   " : ""}` +
        `simTime: ${formatTime(simTime)}  (${simTime.toFixed(1)}s / ${(SIM_DURATION / 3600).toFixed(0)}h)\n` +
        `person: ${person.hudText()}\n` +
        `[Drag] look (trails pause)   [↑/↓] or +/- speed   [Space] pause   [R] reset   [/] decay: ${TRAIL_DECAY.toFixed(3)}   substeps: ${subSteps}`;
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      post.mat.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
      resizeRenderTarget();
    });
    resizeRenderTarget();

    function resizeRenderTarget() {
      const pr = renderer.getPixelRatio();
      const w = Math.max(1, Math.floor(window.innerWidth * pr));
      const h = Math.max(1, Math.floor(window.innerHeight * pr));
      post.sceneRT.setSize(w, h);
      post.warpRT.setSize(w, h);
      post.accumA.setSize(w, h);
      post.accumB.setSize(w, h);
      post.trailMat.uniforms.texel.value.set(1 / w, 1 / h);
      clearAccum();
    }

    function clearAccum() {
      const prevClear = renderer.getClearColor(new THREE.Color()).getHex();
      const prevAlpha = renderer.getClearAlpha();
      renderer.setClearColor(0x000000, 1);
      renderer.setRenderTarget(post.accumA);
      renderer.clear(true, true, true);
      renderer.setRenderTarget(post.accumB);
      renderer.clear(true, true, true);
      renderer.setRenderTarget(null);
      renderer.setClearColor(prevClear, prevAlpha);
    }

    // ----------------------------
    // Stars (static backdrop)
    // ----------------------------
    function buildStaticStars() {
      let remaining = STAR_COUNT;
      for (let si = 0; si < STAR_SHELLS.length; si++) {
        const shellCount = si === STAR_SHELLS.length - 1 ? remaining : Math.floor(STAR_COUNT * STAR_SHELLS[si].fraction);
        remaining -= shellCount;
        let remLayer = shellCount;
        for (let li = 0; li < STAR_LAYERS.length; li++) {
          const count = li === STAR_LAYERS.length - 1 ? remLayer : Math.floor(shellCount * STAR_LAYERS[li].fraction);
          remLayer -= count;
          if (count <= 0) continue;
          starGroups.push(createStaticStars(count, STAR_LAYERS[li].size, DOME_RADIUS * STAR_SHELLS[si].radiusMul));
        }
      }
    }

    function createStaticStars(count, size, radius) {
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const inCluster = Math.random() < CLUSTER_FRACTION;
        let theta, phi;
        if (inCluster) {
          const cid = Math.floor(Math.random() * VENUE_COUNT);
          const sh = VENUE_SHAPE[cid];
          const ang = VENUE_ORIENT[cid];
          const cs = Math.cos(ang), sn = Math.sin(ang);
          let x = randn() * CLUSTER_SIGMA_THETA;
          let y = randn() * CLUSTER_SIGMA_PHI;
          if (sh === 1) {
            const asp = VENUE_ASPECT[cid];
            x *= asp;
            y *= 0.35;
          } else if (sh === 2) {
            const asp = VENUE_ASPECT[cid];
            const u = randn() * 0.9;
            x = u * CLUSTER_SIGMA_THETA * asp;
            y = (0.35 * u * u + randn() * 0.35) * CLUSTER_SIGMA_PHI;
          }
          const rx = x * cs - y * sn;
          const ry = x * sn + y * cs;
          theta = wrapAngle(VENUE_THETA[cid] + rx);
          phi = clampPhi(VENUE_PHI[cid] + ry);
        } else {
          theta = Math.random() * Math.PI * 2;
          const cosPhiMax = Math.cos(DOME_PHI_MAX);
          const cosPhi = cosPhiMax + (1 - cosPhiMax) * Math.random();
          phi = Math.acos(cosPhi);
        }

        const p = sphericalToCartesian(theta, phi, radius);
        positions[i * 3 + 0] = p.x;
        positions[i * 3 + 1] = p.y + CAMERA_EYE_HEIGHT;
        positions[i * 3 + 2] = p.z;

        // Slight temperature tint
        const temp = Math.random();
        let r = 1, g = 1, b = 1;
        if (temp < 0.14) { r = 1.0; g = 0.94; b = 0.86; }
        else if (temp < 0.30) { r = 0.86; g = 0.92; b = 1.0; }
        else { r = 0.98; g = 0.99; b = 1.0; }
        const bright = 0.22 + Math.pow(Math.random(), 2.0) * 0.95;
        colors[i * 3 + 0] = r * bright;
        colors[i * 3 + 1] = g * bright;
        colors[i * 3 + 2] = b * bright;
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: size * 1.6,
        map: STAR_SPRITE_TEX,
        transparent: true,
        alphaTest: 0.08,
        opacity: 0.55,
        vertexColors: true,
        depthWrite: false,
        depthTest: false,
        blending: THREE.AdditiveBlending
      });

      const points = new THREE.Points(geom, mat);
      points.renderOrder = 5;
      return points;
    }

    function createPerson() {
      // One point
      const positions = new Float32Array(3);
      const colors = new Float32Array([1, 1, 1]);
      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.055,
        map: STAR_SPRITE_TEX,
        transparent: true,
        alphaTest: 0.10,
        opacity: 0.85,
        vertexColors: true,
        depthWrite: false,
        depthTest: false,
        blending: THREE.AdditiveBlending
      });
      const points = new THREE.Points(geom, mat);
      points.renderOrder = 10;

      // One segment (prev -> curr) drawn each sim micro-step; accumulation makes it long exposure.
      const segPos = new Float32Array(6);
      const segGeom = new THREE.BufferGeometry();
      segGeom.setAttribute("position", new THREE.BufferAttribute(segPos, 3));
      const segMat = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.90,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        depthTest: false
      });
      const seg = new THREE.LineSegments(segGeom, segMat);
      seg.renderOrder = 11;

      // Itinerary: visit all 5 venues in a shuffled order.
      const order = [0, 1, 2, 3, 4];
      shuffleInPlace(order);

      const st = {
        state: STATE_WAIT,
        venueOrder: order,
        venueIdx: 0,
        targetVenue: order[0],
        // Anchor in spherical
        theta: wrapAngle(ENTRANCE_THETA + randn() * ENTRANCE_SPREAD_THETA),
        phi: clampPhi(ENTRANCE_PHI + randn() * ENTRANCE_SPREAD_PHI),
        prevX: 0, prevY: 0, prevZ: 0,
        // Segment (bezier) params
        segT: 0,
        segDur: 1,
        th0u: 0, th3u: 0,
        ph0: 0, ph3: 0,
        c1Th: 0, c2Th: 0,
        c1Ph: 0, c2Ph: 0,
        // Linger/orbit
        lingerLeft: 0,
        orbitPhase: Math.random() * Math.PI * 2,
        orbitSpeed: randRange(ORBIT_SPEED[0], ORBIT_SPEED[1]),
        orbitRTh: randRange(ORBIT_R_THETA[0], ORBIT_R_THETA[1]),
        orbitRPh: randRange(ORBIT_R_PHI[0], ORBIT_R_PHI[1]),
        // Start time
        startTime: Math.pow(Math.random(), 1.5) * 18.0, // within ~18s
        // For HUD
        lastAction: "waiting"
      };

      // init cartesian + segment
      const p0 = sphericalToCartesian(st.theta, st.phi, DOME_RADIUS * 0.93);
      positions[0] = p0.x;
      positions[1] = p0.y + CAMERA_EYE_HEIGHT;
      positions[2] = p0.z;
      st.prevX = positions[0];
      st.prevY = positions[1];
      st.prevZ = positions[2];
      segPos[0] = st.prevX; segPos[1] = st.prevY; segPos[2] = st.prevZ;
      segPos[3] = st.prevX; segPos[4] = st.prevY; segPos[5] = st.prevZ;

      function hudText() {
        const v = st.state === STATE_LINGER ? st.targetVenue : (st.state === STATE_TRANSIT ? st.targetVenue : (st.venueOrder[st.venueIdx] ?? -1));
        const venueLabel = v >= 0 ? `${(st.venueIdx + (st.state === STATE_LINGER ? 0 : 0))}/${VENUE_COUNT} (venue ${v + 1})` : "—";
        const sName =
          st.state === STATE_WAIT ? "entering" :
            st.state === STATE_TRANSIT ? "transit" :
              st.state === STATE_LINGER ? "linger" :
                st.state === STATE_EXITING ? "exit" : "exited";
        return `${sName}  ${venueLabel}  ${st.lastAction}`;
      }

      function reset() {
        shuffleInPlace(order);
        st.venueIdx = 0;
        st.targetVenue = order[0];
        st.state = STATE_WAIT;
        st.theta = wrapAngle(ENTRANCE_THETA + randn() * ENTRANCE_SPREAD_THETA);
        st.phi = clampPhi(ENTRANCE_PHI + randn() * ENTRANCE_SPREAD_PHI);
        st.segT = 0; st.segDur = 1;
        st.lingerLeft = 0;
        st.orbitPhase = Math.random() * Math.PI * 2;
        st.orbitSpeed = randRange(ORBIT_SPEED[0], ORBIT_SPEED[1]);
        st.orbitRTh = randRange(ORBIT_R_THETA[0], ORBIT_R_THETA[1]);
        st.orbitRPh = randRange(ORBIT_R_PHI[0], ORBIT_R_PHI[1]);
        st.startTime = Math.pow(Math.random(), 1.5) * 18.0;
        st.lastAction = "waiting";
        const p = sphericalToCartesian(st.theta, st.phi, DOME_RADIUS * 0.93);
        positions[0] = p.x; positions[1] = p.y + CAMERA_EYE_HEIGHT; positions[2] = p.z;
        st.prevX = positions[0]; st.prevY = positions[1]; st.prevZ = positions[2];
        segPos[0] = st.prevX; segPos[1] = st.prevY; segPos[2] = st.prevZ;
        segPos[3] = st.prevX; segPos[4] = st.prevY; segPos[5] = st.prevZ;
        geom.attributes.position.needsUpdate = true;
        segGeom.attributes.position.needsUpdate = true;
      }

      return { points, seg, st, positions, segPos, geom, segGeom, hudText, reset };
    }

    function resetPerson() {
      person.reset();
    }

    function buildSegmentTo(targetTheta, targetPhi, travelHintSec) {
      const st = person.st;
      const th0 = st.theta;
      const ph0 = st.phi;
      const dTh = angleDelta(th0, targetTheta);
      const dPh = targetPhi - ph0;
      const dist = Math.sqrt(dTh * dTh + dPh * dPh);

      // Duration is minutes-ish. The "hint" is optional; otherwise computed from dist.
      const dur = travelHintSec != null
        ? travelHintSec
        : Math.max(90.0, Math.min(12 * 60, dist / Math.max(1e-6, WALK_SPEED) * 9.0));

      st.segDur = dur;
      st.segT = 0;

      const th0u = th0;
      const th3u = th0u + dTh;
      st.th0u = th0u;
      st.th3u = th3u;
      st.ph0 = ph0;
      st.ph3 = targetPhi;

      // Base straight controls
      let c1Th = th0u + (th3u - th0u) * (1 / 3);
      let c2Th = th0u + (th3u - th0u) * (2 / 3);
      let c1Ph = ph0 + (targetPhi - ph0) * (1 / 3);
      let c2Ph = ph0 + (targetPhi - ph0) * (2 / 3);

      // Always curved (but gentle)
      if (dist > 0.02) {
        const inv = 1.0 / dist;
        const vx = dTh * inv;
        const vy = dPh * inv;
        const px = -vy;
        const py = vx;
        const sign = Math.random() < 0.5 ? -1 : 1;
        const amp = sign * Math.min(0.22, Math.max(0.04, dist * (0.12 + Math.random() * 0.10)));
        c1Th += px * amp;
        c2Th += px * amp;
        c1Ph += py * amp;
        c2Ph += py * amp;
      }

      st.c1Th = c1Th;
      st.c2Th = c2Th;
      st.c1Ph = clampPhi(c1Ph);
      st.c2Ph = clampPhi(c2Ph);
    }

    function updatePerson(dt, t) {
      const st = person.st;
      if (st.state === STATE_EXITED) return;

      // Segment endpoints / ink segment updates
      const segPos = person.segPos;
      const prevX = person.positions[0];
      const prevY = person.positions[1];
      const prevZ = person.positions[2];

      if (t < st.startTime) {
        st.state = STATE_WAIT;
        st.lastAction = "waiting at entrance";
        st.theta = wrapAngle(ENTRANCE_THETA + randn() * (ENTRANCE_SPREAD_THETA * 0.25));
        st.phi = clampPhi(ENTRANCE_PHI + randn() * (ENTRANCE_SPREAD_PHI * 0.25));
      } else if (st.state === STATE_WAIT) {
        // Start: go to first venue
        st.state = STATE_TRANSIT;
        st.targetVenue = st.venueOrder[0];
        buildSegmentTo(VENUE_THETA[st.targetVenue], VENUE_PHI[st.targetVenue], 2.5 * 60 + Math.random() * 3.5 * 60);
        st.lastAction = `heading to venue ${st.targetVenue + 1}`;
      } else if (st.state === STATE_TRANSIT || st.state === STATE_EXITING) {
        st.segT += dt;
        const u = clamp01(st.segT / Math.max(1e-6, st.segDur));
        const uu = u * u * (3.0 - 2.0 * u); // smoothstep

        const omt = 1.0 - uu;
        const omt2 = omt * omt;
        const uu2 = uu * uu;
        const b0 = omt2 * omt;
        const b1 = 3.0 * omt2 * uu;
        const b2 = 3.0 * omt * uu2;
        const b3 = uu2 * uu;

        const thU = b0 * st.th0u + b1 * st.c1Th + b2 * st.c2Th + b3 * st.th3u;
        const ph = b0 * st.ph0 + b1 * st.c1Ph + b2 * st.c2Ph + b3 * st.ph3;

        // Gentle meander (zero at endpoints)
        const dThSeg = (st.th3u - st.th0u);
        const dPhSeg = (st.ph3 - st.ph0);
        const distSeg = Math.max(1e-6, Math.sqrt(dThSeg * dThSeg + dPhSeg * dPhSeg));
        const vx = dThSeg / distSeg;
        const vy = dPhSeg / distSeg;
        const px = -vy;
        const py = vx;
        const env = Math.sin(Math.PI * uu);
        const wob = Math.sin(uu * Math.PI * 2.0 * (0.9 + 0.6 * Math.sin(st.targetVenue + 1.7)) + (st.targetVenue * 1.1));
        const amp = (0.010 + 0.010 * Math.sin(st.targetVenue * 3.1)) * env * wob;

        st.theta = wrapAngle(thU + px * amp);
        st.phi = clampPhi(ph + py * amp);

        if (u >= 1.0 - 1e-6) {
          if (st.state === STATE_EXITING) {
            st.state = STATE_EXITED;
            st.lastAction = "exited";
          } else {
            st.state = STATE_LINGER;
            st.lingerLeft = randRange(LINGER_MIN, LINGER_MAX);
            st.orbitPhase = Math.random() * Math.PI * 2;
            st.orbitSpeed = randRange(ORBIT_SPEED[0], ORBIT_SPEED[1]);
            st.orbitRTh = randRange(ORBIT_R_THETA[0], ORBIT_R_THETA[1]);
            st.orbitRPh = randRange(ORBIT_R_PHI[0], ORBIT_R_PHI[1]);
            st.lastAction = `arrived at venue ${st.targetVenue + 1}`;
          }
        }
      } else if (st.state === STATE_LINGER) {
        st.lingerLeft -= dt;
        st.orbitPhase += dt * st.orbitSpeed;
        const cid = st.targetVenue;
        const cx = VENUE_THETA[cid];
        const cy = VENUE_PHI[cid];

        // “More or less circles”: small ellipse around venue center with a little drift.
        const a = st.orbitPhase;
        const drift = Math.sin(a * 0.37 + cid) * 0.004 + Math.sin(a * 0.11 + cid * 1.7) * 0.003;
        st.theta = wrapAngle(cx + Math.cos(a) * st.orbitRTh + drift);
        st.phi = clampPhi(cy + Math.sin(a) * st.orbitRPh + drift * 0.7);

        if (st.lingerLeft <= 0) {
          st.venueIdx++;
          if (st.venueIdx >= st.venueOrder.length) {
            // Exit
            st.state = STATE_EXITING;
            st.lastAction = "heading to exit";
            buildSegmentTo(ENTRANCE_THETA, ENTRANCE_PHI, 3.0 * 60 + Math.random() * 5.0 * 60);
          } else {
            // Next venue
            st.state = STATE_TRANSIT;
            st.targetVenue = st.venueOrder[st.venueIdx];
            st.lastAction = `heading to venue ${st.targetVenue + 1}`;
            buildSegmentTo(VENUE_THETA[st.targetVenue], VENUE_PHI[st.targetVenue], 3.0 * 60 + Math.random() * 7.0 * 60);
          }
        }
      }

      // Update point position in cartesian space (on a mid shell so it "sits" with the stars)
      const p = sphericalToCartesian(st.theta, st.phi, DOME_RADIUS * 0.93);
      person.positions[0] = p.x;
      person.positions[1] = p.y + CAMERA_EYE_HEIGHT;
      person.positions[2] = p.z;
      person.geom.attributes.position.needsUpdate = true;

      // Update short ink segment (prev -> curr)
      segPos[0] = prevX; segPos[1] = prevY; segPos[2] = prevZ;
      segPos[3] = person.positions[0]; segPos[4] = person.positions[1]; segPos[5] = person.positions[2];
      person.segGeom.attributes.position.needsUpdate = true;

      // If exited, stop drawing new ink
      if (st.state === STATE_EXITED) {
        person.seg.visible = false;
        person.points.visible = false;
      } else {
        person.seg.visible = true;
        person.points.visible = true;
      }
    }

    // ----------------------------
    // Venues (5)
    // ----------------------------
    function initVenues() {
      const phiMin = 1.35;
      const phiMax = Math.min(DOME_PHI_MAX - 0.12, 2.10);
      const twoPi = Math.PI * 2;
      for (let c = 0; c < VENUE_COUNT; c++) {
        const base = (c / VENUE_COUNT) * twoPi;
        VENUE_THETA[c] = wrapAngle(base + randn() * 0.35);
        VENUE_PHI[c] = clampPhi(randRange(phiMin, phiMax) + randn() * 0.06);
        const r = Math.random();
        VENUE_SHAPE[c] = r < 0.62 ? 0 : r < 0.84 ? 1 : 2;
        VENUE_ORIENT[c] = Math.random() * twoPi;
        VENUE_ASPECT[c] = VENUE_SHAPE[c] === 0 ? 1.0 : 2.2 + Math.random() * 3.2;
      }
    }

    // ----------------------------
    // Helpers
    // ----------------------------
    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function clampPhi(p) { return Math.max(0.02, Math.min(DOME_PHI_MAX, p)); }
    function wrapAngle(a) { const twoPi = Math.PI * 2; a = a % twoPi; return a < 0 ? a + twoPi : a; }
    function angleDelta(from, to) { let d = (to - from) % (Math.PI * 2); if (d > Math.PI) d -= Math.PI * 2; if (d < -Math.PI) d += Math.PI * 2; return d; }
    function randRange(a, b) { return a + Math.random() * (b - a); }

    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        const t = arr[i]; arr[i] = arr[j]; arr[j] = t;
      }
    }

    // Gaussian-ish noise
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function sphericalToCartesian(theta, phi, r) {
      // theta around Y axis, phi from +Y
      const sinPhi = Math.sin(phi);
      return {
        x: r * sinPhi * Math.sin(theta),
        y: r * Math.cos(phi),
        z: r * sinPhi * Math.cos(theta)
      };
    }

    function formatTime(seconds) {
      const s = Math.max(0, seconds);
      const hh = Math.floor(s / 3600);
      const mm = Math.floor((s % 3600) / 60);
      const ss = Math.floor(s % 60);
      const pad = (n) => String(n).padStart(2, "0");
      return `${pad(hh)}:${pad(mm)}:${pad(ss)}`;
    }

    function createSkyTexture(w, h) {
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, w, h);
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function makeStarSpriteTexture() {
      const size = 128;
      const c = document.createElement("canvas");
      c.width = size; c.height = size;
      const ctx = c.getContext("2d");
      const cx = size * 0.5;
      const cy = size * 0.5;
      const r = size * 0.5;
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      g.addColorStop(0.0, "rgba(255,255,255,1.00)");
      g.addColorStop(0.12, "rgba(255,255,255,1.00)");
      g.addColorStop(0.26, "rgba(255,255,255,0.72)");
      g.addColorStop(0.42, "rgba(255,255,255,0.16)");
      g.addColorStop(1.0, "rgba(255,255,255,0.00)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
  </script>
</body>

</html>


