<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Plot Thickens — Planetarium Stars Mockup</title>
  <style>
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    canvas {
      display: block;
    }

    .hud {
      position: fixed;
      left: 16px;
      top: 14px;
      color: rgba(255, 255, 255, 0.78);
      font-size: 13px;
      line-height: 1.35;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 12px rgba(0, 0, 0, 0.85);
    }

    .hint {
      position: fixed;
      left: 16px;
      bottom: 14px;
      color: rgba(255, 255, 255, 0.62);
      font-size: 12px;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 12px rgba(0, 0, 0, 0.85);
    }
  </style>
</head>

<body>
  <div class="hud">
    The Plot Thickens — planetarium mockup<br />
    Dome = night sky; stars drift/twinkle at different paces (some still)
  </div>
  <div class="hint">No movement trails are drawn in this version.</div>

  <!-- three.js r182 -->
  <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";

    const DOME_RADIUS = 10;
    const CAMERA_EYE_HEIGHT = 1.55;
    // We render more than a hemisphere so the dome visually fills the entire screen.
    // (A pure hemisphere leaves a visible empty band at the bottom in a full-screen view.)
    const DOME_PHI_MAX = Math.PI * 0.86;

    const STAR_COUNT = 6500;
    // More size variety (separate point clouds; PointsMaterial has a single size per cloud).
    const STAR_LAYERS = [
      { fraction: 0.46, size: 0.012 },
      { fraction: 0.26, size: 0.017 },
      { fraction: 0.14, size: 0.024 },
      { fraction: 0.08, size: 0.034 },
      // Slightly larger “prominent” stars (+20%)
      { fraction: 0.045, size: 0.050 },
      { fraction: 0.015, size: 0.082 }
    ];

    // Motion/behavior tuning (aim: human pace — pause, then move, plus gentle clustering).
    const CLUSTER_COUNT = 6;
    const CLUSTER_FRACTION = 0.62; // % of stars that "belong" to a cluster
    const CLUSTER_SIGMA_THETA = 0.22; // radians
    const CLUSTER_SIGMA_PHI = 0.16; // radians
    const IDLE_SECONDS = [1.2, 6.5]; // min/max
    const MOVE_SECONDS = [0.7, 3.6]; // min/max
    const HUMAN_SPEED = [0.00007, 0.00040]; // rad/sec baseline speed while moving (slower)
    const GROUPED_FRACTION = 0.82; // most stars move in small groups
    const GROUP_SIZE_WEIGHTS = [
      { n: 2, w: 0.46 },
      { n: 3, w: 0.34 },
      { n: 4, w: 0.20 }
    ];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000006);

    // Wider FOV + upward view so the dome fills most of the screen (not just the top third).
    const camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.05, 200);
    camera.position.set(0, CAMERA_EYE_HEIGHT, 0);
    camera.lookAt(0, CAMERA_EYE_HEIGHT + 0.4, -1);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    // Round star sprite (canvas -> texture). This is the standard way to avoid square WebGL points.
    // Ref pattern: https://www.geeksforgeeks.org/reactjs/creating-a-dynamic-background-effect-with-moving-stars-and-centered-image/
    const STAR_SPRITE_TEX = makeStarSpriteTexture();

    // --- Sky dome (subtle gradient + noise texture) ---
    const skyTex = createSkyTexture(1024, 512);
    skyTex.wrapS = THREE.RepeatWrapping;
    skyTex.wrapT = THREE.ClampToEdgeWrapping;
    skyTex.anisotropy = 4;

    const domeGeo = new THREE.SphereGeometry(DOME_RADIUS, 64, 48, 0, Math.PI * 2, 0, DOME_PHI_MAX);
    const domeMat = new THREE.MeshBasicMaterial({
      side: THREE.BackSide,
      map: skyTex,
      transparent: false
    });
    const dome = new THREE.Mesh(domeGeo, domeMat);
    dome.position.y = CAMERA_EYE_HEIGHT; // center the dome around viewer height (planetarium feel)
    // Important: never let the dome occlude stars.
    dome.renderOrder = -10;
    domeMat.depthWrite = false;
    scene.add(dome);

    // --- Horizon Glow (defines the planetarium dome shape) ---
    const horizonBand = 0.32;
    const horizonStart = Math.max(0, DOME_PHI_MAX - horizonBand);
    const horizonGeo = new THREE.SphereGeometry(
      DOME_RADIUS * 0.98,
      64,
      16,
      0,
      Math.PI * 2,
      horizonStart,
      horizonBand
    );
    const horizonMat = new THREE.ShaderMaterial({
      transparent: true,
      side: THREE.BackSide,
      depthWrite: false,
      depthTest: false,
      uniforms: {
        color: { value: new THREE.Color(0x1a2b44) } // Deep subtle blue-ish glow
      },
      vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
      fragmentShader: `
          varying vec3 vNormal;
          uniform vec3 color;
          void main() {
            // Gradient fading out as it goes up
            float intensity = pow(0.7 - dot(vNormal, vec3(0, 1, 0)), 3.0);
            gl_FragColor = vec4(color, intensity * 0.6);
          }
        `
    });
    const horizon = new THREE.Mesh(horizonGeo, horizonMat);
    horizon.renderOrder = -5;
    scene.add(horizon);

    // --- Stars (3 layers: small/medium/large) ---
    const starGroups = [];
    let remaining = STAR_COUNT;
    for (let i = 0; i < STAR_LAYERS.length; i++) {
      const count =
        i === STAR_LAYERS.length - 1 ? remaining : Math.floor(STAR_COUNT * STAR_LAYERS[i].fraction);
      remaining -= count;
      starGroups.push(createStars(count, STAR_LAYERS[i].size));
    }
    starGroups.forEach((g) => scene.add(g.points));

    // Gentle camera drift (like a seated viewer turning their head)
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      const t = clock.elapsedTime;

      // Update star motion + twinkle
      for (const g of starGroups) {
        updateStars(g, dt, t);
      }

      // Slow yaw + small nod (bias upward to keep the dome dominant in frame)
      // Keep camera drift extremely subtle; the star motion should read as independent.
      const yaw = Math.sin(t * 0.03) * 0.05 + Math.sin(t * 0.011) * 0.025;
      const pitch = 0.62 + Math.sin(t * 0.04) * 0.02;
      const dir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));
      camera.lookAt(camera.position.clone().add(dir));

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ----------------------------
    // Stars
    // ----------------------------
    function createStars(count, size) {
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const baseColors = new Float32Array(count * 3); // stable per-star color (no frame-to-frame compounding)

      // Per-star dynamics in spherical coords (theta, phi)
      const theta = new Float32Array(count);
      const phi = new Float32Array(count);
      const clusterId = new Int16Array(count); // -1 means "not in a cluster"

      // Group motion: most stars belong to a small group (2–4). Each group has an anchor that wanders,
      // and each star has a fixed offset around that anchor (so groups "travel together").
      const groupId = new Int32Array(count);
      const offTheta = new Float32Array(count);
      const offPhi = new Float32Array(count);

      // mild micro-jitter so motion doesn't look mechanical
      const jitterPhaseA = new Float32Array(count);
      const jitterPhaseB = new Float32Array(count);
      const jitterSpd = new Float32Array(count);

      const baseB = new Float32Array(count);
      const twinkleSpd = new Float32Array(count);
      const twinklePhase = new Float32Array(count);

      // Cluster centers (shared within this layer)
      const clustersTheta = new Float32Array(CLUSTER_COUNT);
      const clustersPhi = new Float32Array(CLUSTER_COUNT);
      const clustersDriftA = new Float32Array(CLUSTER_COUNT);
      const clustersDriftB = new Float32Array(CLUSTER_COUNT);
      for (let c = 0; c < CLUSTER_COUNT; c++) {
        clustersTheta[c] = Math.random() * Math.PI * 2;
        // keep centers away from the extreme bottom edge
        const cosPhiMax = Math.cos(DOME_PHI_MAX);
        const cosPhi = cosPhiMax + (1 - cosPhiMax) * Math.random();
        clustersPhi[c] = Math.acos(cosPhi);
        clustersDriftA[c] = Math.random() * Math.PI * 2;
        clustersDriftB[c] = Math.random() * Math.PI * 2;
      }

      // Build groups while initializing, so members start near each other.
      let i = 0;
      let gCount = 0;
      const gAnchorTheta = [];
      const gAnchorPhi = [];
      const gVelTheta = [];
      const gVelPhi = [];
      const gCluster = [];
      const gAct = [];
      const gActBase = [];
      const gNoiseA = [];
      const gNoiseB = [];

      while (i < count) {
        const makeGroup = Math.random() < GROUPED_FRACTION;
        const groupSize = makeGroup ? pickGroupSize() : 1;
        const actualSize = Math.min(groupSize, count - i);

        // Choose an anchor location (often near a cluster center)
        const inCluster = Math.random() < CLUSTER_FRACTION;
        let cid = -1;
        if (inCluster) cid = Math.floor(Math.random() * CLUSTER_COUNT);
        gCluster[gCount] = cid;

        let aTheta, aPhi;
        if (cid >= 0) {
          aTheta = wrapAngle(clustersTheta[cid] + randn() * (CLUSTER_SIGMA_THETA * 0.6));
          aPhi = clampPhi(clustersPhi[cid] + randn() * (CLUSTER_SIGMA_PHI * 0.6));
        } else {
          aTheta = Math.random() * Math.PI * 2;
          const cosPhiMax = Math.cos(DOME_PHI_MAX);
          const cosPhi = cosPhiMax + (1 - cosPhiMax) * Math.random();
          aPhi = Math.acos(cosPhi);
        }

        gAnchorTheta[gCount] = aTheta;
        gAnchorPhi[gCount] = aPhi;

        // Group "activity" controls how much it moves (creates organic pause/move without a uniform timer).
        gAct[gCount] = Math.random();
        gActBase[gCount] = 0.22 + Math.random() * 0.28;
        gNoiseA[gCount] = Math.random() * Math.PI * 2;
        gNoiseB[gCount] = Math.random() * Math.PI * 2;

        // Start with a tiny velocity (random direction)
        const sp = randRange(HUMAN_SPEED[0], HUMAN_SPEED[1]);
        gVelTheta[gCount] = (Math.random() - 0.5) * sp * 2.0;
        gVelPhi[gCount] = (Math.random() - 0.5) * sp * 1.6;

        for (let k = 0; k < actualSize; k++) {
          const idx = i + k;
          groupId[idx] = gCount;
          clusterId[idx] = cid;

          // Members sit around the anchor (small fixed offsets).
          offTheta[idx] = randn() * (0.035 + Math.random() * 0.05);
          offPhi[idx] = randn() * (0.025 + Math.random() * 0.04);

          theta[idx] = wrapAngle(aTheta + offTheta[idx]);
          phi[idx] = clampPhi(aPhi + offPhi[idx]);

          jitterSpd[idx] = 0.12 + Math.random() * 0.65;
          jitterPhaseA[idx] = Math.random() * Math.PI * 2;
          jitterPhaseB[idx] = Math.random() * Math.PI * 2;

          // Brightness + twinkle (many subtle, few brighter)
          const b = Math.pow(Math.random(), 2.2);
          baseB[idx] = 0.18 + b * 0.9;
          // Gentler, slower twinkle (avoid “glitter” / popping).
          twinkleSpd[idx] = 0.08 + Math.random() * 0.55;
          twinklePhase[idx] = Math.random() * Math.PI * 2;

          // Color temperature (white/blue-ish/yellow-ish)
          const temp = Math.random();
          let r = 1,
            g = 1,
            bcol = 1;
          if (temp < 0.14) {
            r = 1.0;
            g = 0.94;
            bcol = 0.86;
          } else if (temp < 0.30) {
            r = 0.86;
            g = 0.92;
            bcol = 1.0;
          } else {
            r = 0.98;
            g = 0.99;
            bcol = 1.0;
          }

          // Initial position + color
          const p = sphericalToCartesian(theta[idx], phi[idx], DOME_RADIUS * 0.995);
          positions[idx * 3 + 0] = p.x;
          positions[idx * 3 + 1] = p.y + CAMERA_EYE_HEIGHT;
          positions[idx * 3 + 2] = p.z;

          // Store stable base color; actual display color is computed each frame from twinkle.
          baseColors[idx * 3 + 0] = r;
          baseColors[idx * 3 + 1] = g;
          baseColors[idx * 3 + 2] = bcol;

          const bright = baseB[idx];
          colors[idx * 3 + 0] = r * bright;
          colors[idx * 3 + 1] = g * bright;
          colors[idx * 3 + 2] = bcol * bright;
        }

        i += actualSize;
        gCount++;
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: size * 2.0,
        map: STAR_SPRITE_TEX,
        transparent: true,
        alphaTest: 0.12, // crisper edge; reduces soft “glow square” artifacts
        opacity: 1.0,
        depthWrite: false,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true
      });

      const points = new THREE.Points(geom, mat);
      // Make sure stars render on top of the dome/horizon regardless of sorting.
      points.renderOrder = 10;

      return {
        points,
        theta,
        phi,
        clusterId,
        groupId,
        offTheta,
        offPhi,
        gAnchorTheta: Float32Array.from(gAnchorTheta),
        gAnchorPhi: Float32Array.from(gAnchorPhi),
        gVelTheta: Float32Array.from(gVelTheta),
        gVelPhi: Float32Array.from(gVelPhi),
        gCluster: Int16Array.from(gCluster),
        gAct: Float32Array.from(gAct),
        gActBase: Float32Array.from(gActBase),
        gNoiseA: Float32Array.from(gNoiseA),
        gNoiseB: Float32Array.from(gNoiseB),
        jitterSpd,
        jitterPhaseA,
        jitterPhaseB,
        clustersTheta,
        clustersPhi,
        clustersDriftA,
        clustersDriftB,
        baseColors,
        baseB,
        twinkleSpd,
        twinklePhase
      };
    }

    function updateStars(g, dt, t) {
      const posAttr = g.points.geometry.getAttribute("position");
      const colAttr = g.points.geometry.getAttribute("color");

      // Very slow drift of cluster centers (clusters "breathe" rather than stay frozen).
      for (let c = 0; c < g.clustersTheta.length; c++) {
        const drift = 0.00008; // rad/sec (tiny)
        g.clustersTheta[c] = wrapAngle(
          g.clustersTheta[c] + Math.sin(t * 0.07 + g.clustersDriftA[c]) * drift * dt * 60
        );
        g.clustersPhi[c] = clampPhi(
          g.clustersPhi[c] + Math.cos(t * 0.05 + g.clustersDriftB[c]) * (drift * 0.6) * dt * 60
        );
      }

      // Update group anchors with irregular, human-like motion.
      for (let gi = 0; gi < g.gAnchorTheta.length; gi++) {
        // Activity as a smooth noisy signal (not a uniform timer): produces natural pauses and short moves.
        const kAct = 0.25;
        const nAct = 0.18 * Math.sqrt(dt);
        g.gAct[gi] = clamp01(g.gAct[gi] + (g.gActBase[gi] - g.gAct[gi]) * kAct * dt + randn() * nAct);

        // Occasionally nudge base activity up/down (breaks uniformity across groups).
        if (Math.random() < dt * 0.03) {
          g.gActBase[gi] = clamp01(g.gActBase[gi] + (Math.random() - 0.5) * 0.18);
          g.gActBase[gi] = 0.12 + g.gActBase[gi] * 0.55; // keep mostly calm
        }

        // Velocity is an OU-like process (wanders, then recenters).
        const kV = 0.55;
        const sp = randRange(HUMAN_SPEED[0], HUMAN_SPEED[1]);
        const noise = sp * 0.9 * Math.sqrt(dt);
        g.gVelTheta[gi] = g.gVelTheta[gi] * (1 - kV * dt) + randn() * noise;
        g.gVelPhi[gi] = g.gVelPhi[gi] * (1 - kV * dt) + randn() * (noise * 0.75);

        // Apply activity (0..1) as a throttle.
        const throttle = 0.10 + g.gAct[gi] * 0.95;
        let dTh = g.gVelTheta[gi] * throttle * dt;
        let dPh = g.gVelPhi[gi] * throttle * dt;

        // Gentle pull toward the group's assigned cluster center (keeps clusters visible).
        const cid = g.gCluster[gi];
        if (cid >= 0) {
          const pull = 0.07;
          dTh += angleDelta(g.gAnchorTheta[gi], g.clustersTheta[cid]) * pull * dt;
          dPh += (g.clustersPhi[cid] - g.gAnchorPhi[gi]) * pull * dt;
        }

        g.gAnchorTheta[gi] = wrapAngle(g.gAnchorTheta[gi] + dTh);
        g.gAnchorPhi[gi] = clampPhi(g.gAnchorPhi[gi] + dPh);
      }

      for (let i = 0; i < g.theta.length; i++) {
        const gi = g.groupId[i];
        const desiredTheta = wrapAngle(g.gAnchorTheta[gi] + g.offTheta[i]);
        const desiredPhi = clampPhi(g.gAnchorPhi[gi] + g.offPhi[i]);

        // Spring toward the group position (keeps 2–4 stars moving together).
        const spring = 0.85;
        const dTh = angleDelta(g.theta[i], desiredTheta);
        const dPh = desiredPhi - g.phi[i];

        // Personal fidget/jitter (breaks uniform group motion).
        const j = 0.00005;
        const ja = Math.sin(t * g.jitterSpd[i] + g.jitterPhaseA[i]) * j;
        const jb = Math.cos(t * (g.jitterSpd[i] * 0.83 + 0.03) + g.jitterPhaseB[i]) * j;

        g.theta[i] = wrapAngle(g.theta[i] + (dTh * spring + ja) * dt);
        g.phi[i] = clampPhi(g.phi[i] + (dPh * spring + jb) * dt);

        // Keep within the dome cap so stars stay on the rendered sky.
        if (g.phi[i] < 0.02) g.phi[i] = 0.02;
        if (g.phi[i] > DOME_PHI_MAX) g.phi[i] = DOME_PHI_MAX;

        const p = sphericalToCartesian(g.theta[i], g.phi[i], DOME_RADIUS * 0.995);
        posAttr.array[i * 3 + 0] = p.x;
        posAttr.array[i * 3 + 1] = p.y + CAMERA_EYE_HEIGHT;
        posAttr.array[i * 3 + 2] = p.z;

        // Twinkle: very subtle brightness modulation, computed from stable base color.
        const tw = 0.04 * Math.sin(t * g.twinkleSpd[i] + g.twinklePhase[i]);
        const bright = clamp01(g.baseB[i] + tw);

        colAttr.array[i * 3 + 0] = g.baseColors[i * 3 + 0] * bright;
        colAttr.array[i * 3 + 1] = g.baseColors[i * 3 + 1] * bright;
        colAttr.array[i * 3 + 2] = g.baseColors[i * 3 + 2] * bright;
      }

      posAttr.needsUpdate = true;
      colAttr.needsUpdate = true;
    }

    function sphericalToCartesian(theta, phi, r) {
      // phi is angle from +Y (zenith). For a dome above: Y positive.
      const sinPhi = Math.sin(phi);
      return new THREE.Vector3(r * sinPhi * Math.cos(theta), r * Math.cos(phi), r * sinPhi * Math.sin(theta));
    }

    function clamp01(x) {
      return Math.max(0, Math.min(1, x));
    }

    function clampPhi(p) {
      return Math.max(0.02, Math.min(DOME_PHI_MAX, p));
    }

    function wrapAngle(a) {
      const twoPi = Math.PI * 2;
      a = a % twoPi;
      return a < 0 ? a + twoPi : a;
    }

    function angleDelta(from, to) {
      // shortest signed delta in [-pi, pi]
      let d = (to - from) % (Math.PI * 2);
      if (d > Math.PI) d -= Math.PI * 2;
      if (d < -Math.PI) d += Math.PI * 2;
      return d;
    }

    function randRange(a, b) {
      return a + Math.random() * (b - a);
    }

    function pickGroupSize() {
      const r = Math.random();
      let acc = 0;
      for (const it of GROUP_SIZE_WEIGHTS) {
        acc += it.w;
        if (r <= acc) return it.n;
      }
      return GROUP_SIZE_WEIGHTS[GROUP_SIZE_WEIGHTS.length - 1].n;
    }

    function smoothstep(edge0, edge1, x) {
      const t = clamp01((x - edge0) / (edge1 - edge0));
      return t * t * (3 - 2 * t);
    }

    function randn() {
      // Box-Muller
      let u = 0,
        v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // ----------------------------
    // Texture: subtle planetarium sky (gradient + noise)
    // ----------------------------
    function createSkyTexture(w, h) {
      const c = document.createElement("canvas");
      c.width = w;
      c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently: false });

      // Base gradient (deep navy)
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, "#00010a");
      g.addColorStop(0.55, "#000008");
      g.addColorStop(1, "#000004");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      // Soft vignetting
      const vg = ctx.createRadialGradient(w * 0.5, h * 0.25, h * 0.05, w * 0.5, h * 0.35, h * 0.9);
      vg.addColorStop(0, "rgba(0,0,0,0)");
      vg.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = vg;
      ctx.fillRect(0, 0, w, h);

      // Fine noise grain
      const img = ctx.getImageData(0, 0, w, h);
      const data = img.data;
      for (let i = 0; i < data.length; i += 4) {
        const n = (Math.random() - 0.5) * 14; // subtle
        data[i + 0] = clamp255(data[i + 0] + n);
        data[i + 1] = clamp255(data[i + 1] + n);
        data[i + 2] = clamp255(data[i + 2] + n);
      }
      ctx.putImageData(img, 0, 0);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function clamp255(x) {
      return Math.max(0, Math.min(255, x));
    }

    function makeStarSpriteTexture() {
      // Slightly higher-res sprite + sharper falloff = “crisper” points (less blurry glow).
      const size = 128;
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");

      // Soft circular glow: bright core + feathered edge.
      const c = size / 2;
      const grad = ctx.createRadialGradient(c, c, 0, c, c, c);
      grad.addColorStop(0.0, "rgba(255,255,255,1)");
      grad.addColorStop(0.12, "rgba(255,255,255,1)");
      grad.addColorStop(0.26, "rgba(255,255,255,0.72)");
      grad.addColorStop(0.42, "rgba(255,255,255,0.16)");
      grad.addColorStop(1.0, "rgba(255,255,255,0)");

      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      tex.needsUpdate = true;
      return tex;
    }
  </script>
</body>

</html>