<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selà | 3D Cinematic Clocks</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Josefin Sans', sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        .clock-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.6);
            padding: 8px 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .clock-btn:hover,
        .clock-btn.active {
            border-color: #fff;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 14px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        h2 {
            margin: 10px 0 0 0;
            font-weight: 300;
            font-size: 24px;
            font-family: 'Cormorant Garamond', serif;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
    </style>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400&family=Josefin+Sans:wght@300;400&display=swap"
        rel="stylesheet">
</head>

<body>

    <div id="info">
        <h1 id="artist-name">Selà</h1>
        <h2 id="clock-title">Cinematic Gallery</h2>
    </div>

    <div id="ui">
        <button class="clock-btn active" data-clock="0">Semi-Linear</button>
        <button class="clock-btn" data-clock="1">Ebb & Flow</button>
        <button class="clock-btn" data-clock="2">Universe</button>
        <button class="clock-btn" data-clock="3">Hourglass</button>
    </div>

    <div id="loading" class="loading">Loading 3D Engine...</div>

    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GLOBAL SETUP ---
        const container = document.body;
        const loading = document.getElementById('loading');
        const titleEl = document.getElementById('clock-title');

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // Cinematic fog

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // Post-processing
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 0.8; // Glow strength
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enablePan = false;

        // Clock State
        let currentClockIndex = 0;
        let clockGroup = new THREE.Group();
        scene.add(clockGroup);

        // Time variables
        let time = 0;

        // --- CLOCK IMPLEMENTATIONS ---

        class ClockBase {
            constructor() {
                this.group = new THREE.Group();
            }
            update(delta, now) { }
            dispose() {
                // Helper to clean up memory
                this.group.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else obj.material.dispose();
                    }
                });
            }
        }

        // 1. SEMI-LINEAR CLOCK (3D Blocks)
        class SemiLinearClock extends ClockBase {
            constructor() {
                super();
                this.cubes = [];
                this.setup();
            }

            setup() {
                const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const materialActive = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0x555555,
                    roughness: 0.1,
                    metalness: 0.8
                });
                const materialInactive = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    transparent: true,
                    opacity: 0.3,
                    roughness: 0.9
                });

                // Hours Grid (Top) - 24 blocks (4x6)
                for (let i = 0; i < 24; i++) {
                    const mesh = new THREE.Mesh(geometry, materialInactive.clone());
                    mesh.position.set((i % 6 - 2.5) * 1.2, 4, (Math.floor(i / 6) - 1.5) * 1.2);
                    mesh.userData = { type: 'hour', index: i };
                    this.group.add(mesh);
                    this.cubes.push(mesh);
                }

                // Minutes Grid (Middle) - 60 blocks (10x6)
                for (let i = 0; i < 60; i++) {
                    const mesh = new THREE.Mesh(geometry, materialInactive.clone());
                    mesh.scale.set(0.6, 0.6, 0.6);
                    mesh.position.set((i % 10 - 4.5) * 0.8, 0, (Math.floor(i / 10) - 2.5) * 0.8);
                    mesh.userData = { type: 'minute', index: i };
                    this.group.add(mesh);
                    this.cubes.push(mesh);
                }

                // Seconds Grid (Bottom) - 60 blocks (10x6)
                for (let i = 0; i < 60; i++) {
                    const mesh = new THREE.Mesh(geometry, materialInactive.clone());
                    mesh.scale.set(0.4, 0.4, 0.4);
                    mesh.position.set((i % 10 - 4.5) * 0.5, -3, (Math.floor(i / 10) - 2.5) * 0.5);
                    mesh.userData = { type: 'second', index: i };
                    this.group.add(mesh);
                    this.cubes.push(mesh);
                }
            }

            update(delta, now) {
                const h = now.getHours();
                const m = now.getMinutes();
                const s = now.getSeconds();
                const ms = now.getMilliseconds();

                // Randomize filling logic or linear? Original is semi-linear (random fill up to N)
                // For 3D visual coherence, we'll light them up randomly but keep count correct

                this.cubes.forEach(cube => {
                    let active = false;
                    const idx = cube.userData.index;

                    if (cube.userData.type === 'hour') active = idx < h;
                    if (cube.userData.type === 'minute') active = idx < m;
                    if (cube.userData.type === 'second') active = idx < s;

                    if (active) {
                        cube.material.color.setHex(0xffffff);
                        cube.material.emissive.setHex(0x222222);
                        cube.material.opacity = 1;
                        // Gentle pulse
                        cube.scale.y = THREE.MathUtils.lerp(cube.scale.y, 1.0 + Math.sin(time * 2 + idx) * 0.1, 0.1);
                    } else {
                        cube.material.color.setHex(0x111111);
                        cube.material.emissive.setHex(0x000000);
                        cube.material.opacity = 0.2;
                        cube.scale.y = THREE.MathUtils.lerp(cube.scale.y, 1.0, 0.1);
                    }
                });

                // Slowly rotate the whole group
                this.group.rotation.y = Math.sin(time * 0.1) * 0.2;
            }
        }

        // 2. EBB & FLOW (Breathing Sphere)
        class EbbFlowClock extends ClockBase {
            constructor() {
                super();
                this.setup();
            }

            setup() {
                // Main Sphere
                const geometry = new THREE.IcosahedronGeometry(4, 2); // Low poly for wireframe look
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                this.sphere = new THREE.Mesh(geometry, material);
                this.group.add(this.sphere);

                // Core
                const coreGeo = new THREE.IcosahedronGeometry(2, 4);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xaaaaaa,
                    roughness: 0.4,
                    metalness: 1.0
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.group.add(this.core);

                // Particles
                const particlesGeo = new THREE.BufferGeometry();
                const count = 1000;
                const posArray = new Float32Array(count * 3);
                for (let i = 0; i < count * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 15;
                }
                particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const particlesMat = new THREE.PointsMaterial({
                    size: 0.05,
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.5
                });
                this.particles = new THREE.Points(particlesGeo, particlesMat);
                this.group.add(this.particles);
            }

            update(delta, now) {
                // Breathe based on time (12h cycle in real version, accelerated here for visual)
                // We'll use seconds for the "breath" to make it visible
                const cycle = (Math.sin(time) + 1) / 2; // 0 to 1

                const scale = 1 + cycle * 0.5;
                this.sphere.scale.set(scale, scale, scale);
                this.sphere.rotation.y += delta * 0.1;
                this.sphere.rotation.z += delta * 0.05;

                this.core.scale.set(scale * 0.5, scale * 0.5, scale * 0.5);

                // Particles drift
                this.particles.rotation.y -= delta * 0.02;
            }
        }

        // 3. UNIVERSE CLOCK (Pyramid)
        class UniverseClock extends ClockBase {
            constructor() {
                super();
                this.setup();
            }

            setup() {
                // Big Triangle (Pyramid) - Time Remaining
                const bigGeo = new THREE.ConeGeometry(5, 10, 4);
                const bigMat = new THREE.MeshStandardMaterial({
                    color: 0x050505,
                    roughness: 0.2,
                    metalness: 0.9,
                    flatShading: true
                });
                this.bigPyramid = new THREE.Mesh(bigGeo, bigMat);
                this.group.add(this.bigPyramid);

                // Small Triangle - Time Passed (Tiny, glowing)
                const smallGeo = new THREE.ConeGeometry(0.1, 0.2, 4);
                const smallMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 5
                });
                this.smallPyramid = new THREE.Mesh(smallGeo, smallMat);
                this.smallPyramid.position.set(2, -4, 2); // Corner position
                this.group.add(this.smallPyramid);

                // Stars/Universe background effect is global, but maybe add local dust
            }

            update(delta, now) {
                this.bigPyramid.rotation.y += delta * 0.05;
                this.smallPyramid.rotation.y += delta * 1;

                // Orbit the small one around slightly?
                const angle = time * 0.2;
                this.smallPyramid.position.x = Math.sin(angle) * 3;
                this.smallPyramid.position.z = Math.cos(angle) * 3;
            }
        }

        // 4. HOURGLASS (Particles)
        class HourglassClock extends ClockBase {
            constructor() {
                super();
                this.setup();
            }

            setup() {
                // Top Chamber, Bottom Chamber implied by particle flow
                // We'll just create a stream of falling particles

                const count = 2000;
                this.positions = new Float32Array(count * 3);
                this.speeds = new Float32Array(count);

                for (let i = 0; i < count; i++) {
                    this.positions[i * 3] = (Math.random() - 0.5) * 4; // x
                    this.positions[i * 3 + 1] = Math.random() * 10 - 5; // y
                    this.positions[i * 3 + 2] = (Math.random() - 0.5) * 4; // z
                    this.speeds[i] = 2 + Math.random() * 3;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0xffd700, // Gold sand
                    size: 0.08,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                this.sand = new THREE.Points(geometry, material);
                this.group.add(this.sand);
            }

            update(delta, now) {
                const positions = this.sand.geometry.attributes.position.array;

                for (let i = 0; i < this.speeds.length; i++) {
                    // Fall down
                    positions[i * 3 + 1] -= this.speeds[i] * delta;

                    // Reset if too low
                    if (positions[i * 3 + 1] < -5) {
                        positions[i * 3 + 1] = 5;
                        positions[i * 3] = (Math.random() - 0.5) * 4; // Reset X
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 4; // Reset Z

                        // Constrain to hourglass shape (cone)
                        // If y is high, radius is wide. If y is 0, radius is small.
                        // Simple visualization:
                        // Top cone: y > 0.
                        // Bottom cone: y < 0.
                        // This is a simple rain for now, let's shape it next time if needed
                    }

                    // Constrain to hourglass shape approximation (just funnel logic visually)
                    const y = positions[i * 3 + 1];
                    const radius = Math.abs(y) * 0.4 + 0.1;
                    // Pull x/z towards center if they are outside radius
                    // (Simplified physics)
                }

                this.sand.geometry.attributes.position.needsUpdate = true;
                this.group.rotation.y += delta * 0.1;
            }
        }

        // --- MAIN LOGIC ---

        const clocks = [
            new SemiLinearClock(),
            new EbbFlowClock(),
            new UniverseClock(),
            new HourglassClock()
        ];

        const titles = [
            "Semi-Linear Clock",
            "The Ebb and Flow of Time",
            "Universe Clock",
            "Abstract Hourglass"
        ];

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        const blueLight = new THREE.PointLight(0x0055ff, 2, 100);
        blueLight.position.set(-10, -10, -5);
        scene.add(blueLight);

        // Switcher
        function switchClock(index) {
            scene.remove(clockGroup);
            currentClockIndex = index;
            clockGroup = clocks[index].group;
            scene.add(clockGroup);

            // Update UI
            titleEl.textContent = titles[index];
            document.querySelectorAll('.clock-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });

            // Reset camera animation slightly
            controls.autoRotateSpeed = (index === 1) ? 0.2 : 0.5; // Slow down for ebb/flow
        }

        // Initialize
        switchClock(0);
        loading.style.display = 'none';

        // UI Listeners
        document.querySelectorAll('.clock-btn').forEach((btn, i) => {
            btn.addEventListener('click', () => switchClock(i));
        });

        // Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const now = new Date();
            time += delta;

            controls.update();

            // Update active clock
            if (clocks[currentClockIndex]) {
                clocks[currentClockIndex].update(delta, now);
            }

            composer.render();
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>

